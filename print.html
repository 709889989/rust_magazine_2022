<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Magazine 2022</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The roots aren&#x27;t deep but the seeds are planted!">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="Q1/toc.html"><strong aria-hidden="true">1.</strong> 2022-Q1</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Q1/lang.html"><strong aria-hidden="true">1.1.</strong> 官方动态</a></li><li class="chapter-item "><a href="Q1/hots.html"><strong aria-hidden="true">1.2.</strong> 社区热点</a></li><li class="chapter-item "><a href="Q1/learns.html"><strong aria-hidden="true">1.3.</strong> 学习资源</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Q1/learns/projects.html"><strong aria-hidden="true">1.3.1.</strong> 开源项目</a></li><li class="chapter-item "><a href="Q1/learns/blogs.html"><strong aria-hidden="true">1.3.2.</strong> 博文教程</a></li><li class="chapter-item "><a href="Q1/learns/open-courses.html"><strong aria-hidden="true">1.3.3.</strong> 高校公开课</a></li><li class="chapter-item "><a href="Q1/learns/videso.html"><strong aria-hidden="true">1.3.4.</strong> 线上视频</a></li></ol></li><li class="chapter-item "><a href="Q1/foreign.html"><strong aria-hidden="true">1.4.</strong> 外刊评论</a></li><li class="chapter-item "><a href="Q1/academic.html"><strong aria-hidden="true">1.5.</strong> 学术动态</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Q1/academic/rust.html"><strong aria-hidden="true">1.5.1.</strong> Rust</a></li><li class="chapter-item "><a href="Q1/academic/wasm.html"><strong aria-hidden="true">1.5.2.</strong> WebAssembly</a></li></ol></li><li class="chapter-item "><a href="Q1/opensource.html"><strong aria-hidden="true">1.6.</strong> 领域开源</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Q1/opensource/data.html"><strong aria-hidden="true">1.6.1.</strong> 数据处理</a></li><li class="chapter-item "><a href="Q1/opensource/cloud.html"><strong aria-hidden="true">1.6.2.</strong> 云原生</a></li><li class="chapter-item "><a href="Q1/opensource/game.html"><strong aria-hidden="true">1.6.3.</strong> 游戏与图像处理</a></li><li class="chapter-item "><a href="Q1/opensource/os.html"><strong aria-hidden="true">1.6.4.</strong> 操作系统</a></li><li class="chapter-item "><a href="Q1/opensource/cliapp.html"><strong aria-hidden="true">1.6.5.</strong> 命令行工具</a></li><li class="chapter-item "><a href="Q1/opensource/performance.html"><strong aria-hidden="true">1.6.6.</strong> 性能工具</a></li><li class="chapter-item "><a href="Q1/opensource/network.html"><strong aria-hidden="true">1.6.7.</strong> 网络基建</a></li><li class="chapter-item "><a href="Q1/opensource/web.html"><strong aria-hidden="true">1.6.8.</strong> Web开发</a></li><li class="chapter-item "><a href="Q1/opensource/frontend.html"><strong aria-hidden="true">1.6.9.</strong> 前端基建</a></li><li class="chapter-item "><a href="Q1/opensource/av.html"><strong aria-hidden="true">1.6.10.</strong> 音视频处理</a></li><li class="chapter-item "><a href="Q1/opensource/lang-with-rust.html"><strong aria-hidden="true">1.6.11.</strong> 基于Rust的新编程语言</a></li><li class="chapter-item "><a href="Q1/opensource/embedded.html"><strong aria-hidden="true">1.6.12.</strong> 嵌入式Rust</a></li><li class="chapter-item "><a href="Q1/opensource/security.html"><strong aria-hidden="true">1.6.13.</strong> 信息安全</a></li><li class="chapter-item "><a href="Q1/opensource/scientific-research.html"><strong aria-hidden="true">1.6.14.</strong> 科学艺术</a></li><li class="chapter-item "><a href="Q1/opensource/tools.html"><strong aria-hidden="true">1.6.15.</strong> 其他工具</a></li></ol></li><li class="chapter-item "><a href="Q1/security.html"><strong aria-hidden="true">1.7.</strong> 安全动态</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Q1/security/unsound.html"><strong aria-hidden="true">1.7.1.</strong> Unsound</a></li><li class="chapter-item "><a href="Q1/security/memory.html"><strong aria-hidden="true">1.7.2.</strong> Memory</a></li></ol></li><li class="chapter-item "><a href="Q1/business.html"><strong aria-hidden="true">1.8.</strong> 商业动态</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Q1/business/practices.html"><strong aria-hidden="true">1.8.1.</strong> 生产实践</a></li><li class="chapter-item "><a href="Q1/business/products.html"><strong aria-hidden="true">1.8.2.</strong> 优秀产品</a></li><li class="chapter-item "><a href="Q1/business/blockchain.html"><strong aria-hidden="true">1.8.3.</strong> 区块链</a></li></ol></li><li class="chapter-item "><a href="Q1/libs.html"><strong aria-hidden="true">1.9.</strong> Rust 基础库</a></li><li class="chapter-item "><a href="Q1/contribute.html"><strong aria-hidden="true">1.10.</strong> 应用经验</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Q1/contribute/atom.html"><strong aria-hidden="true">1.10.1.</strong> DatenLord | Rust原子类型和内存排序</a></li><li class="chapter-item "><a href="Q1/contribute/rust-for-linux-clk.html"><strong aria-hidden="true">1.10.2.</strong> Rust for Linux 源码导读 | Rust 驱动开发与通用时钟管理框架抽象</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Magazine 2022</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/RustMagazine/rust_magazine_2022" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="2022年第一季度"><a class="header" href="#2022年第一季度">2022年第一季度</a></h1>
<h2 id="发刊通告"><a class="header" href="#发刊通告">发刊通告</a></h2>
<h2 id="内容目录"><a class="header" href="#内容目录">内容目录</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="官方动态"><a class="header" href="#官方动态">官方动态</a></h1>
<hr />
<h2 id="rust-核心团队有三人宣布退出"><a class="header" href="#rust-核心团队有三人宣布退出">Rust 核心团队有三人宣布退出</a></h2>
<ul>
<li>
<p>Steve Klabnik， 将离开核心团队和安全响应工作组。Steve 9年前开始使用 Rust。自 2014 年以来，他是 Rust 编程语言书（the book）的主要作者和核心团队的一员。他一直在运行 @rustlang Twitter 帐户，因此形成了该项目的许多“声音”。Steve 现在可以专注于使用Rust 而不是制作Rust。</p>
</li>
<li>
<p>Florian Gilcher， 正在退出他所有的项目职位。他于 2019 年成为核心团队的观察员，并于 2020 年成为核心团队的正式成员。他还担任过 Rust 基金会董事会的项目总监。在此之前，他自 2015 年以来一直是社区团队的一员。由于他专注于自己的公司并承担其他业务义务，因此他正在为项目中的其他人腾出空间。</p>
</li>
<li>
<p>Pietro Albini， 将离开核心团队，专注于项目的其他部分，包括基础设施团队和安全响应工作组。他于 2019 年底加入核心团队，在成为基础设施团队的联合负责人后不久，但核心团队的工作量让他很难在项目中的其他角色上花费足够的时间。</p>
</li>
</ul>
<p><a href="https://blog.rust-lang.org/2022/01/31/changes-in-the-core-team.html">https://blog.rust-lang.org/2022/01/31/changes-in-the-core-team.html</a></p>
<h2 id="2022年异步rust的改进计划"><a class="header" href="#2022年异步rust的改进计划">2022年异步Rust的改进计划</a></h2>
<p>Niko Matsakis 和 Tyler Mandry 代表 Async 工作组发布了一篇文章，阐述了在 2022 年异步 Rust 的改进计划。</p>
<p><strong>Rust 2024 Edition 中使用异步 Rust 的愿景</strong></p>
<p>文章中先假设了一个 Rust 2024 edtion 中实现的异步愿景。</p>
<p>假设在 Rust 2024 Edition 中，你使用异步 Rust 创建一个新项目：使用crates.io 的第三方库 <code>crabbycat</code>来遍历指定 GitHub 仓库的issues列表：</p>
<pre><code class="language-rust ignore">async fn main() {
    for await? issue in crabbycat::issues(&quot;https://github.com/rust-lang/rust&quot;) {
        if meets_criteria(&amp;issue) {
            println!(&quot;{issue:?}&quot;);
        }
    }
}
</code></pre>
<p>你的项目似乎工作正常，这个时候有人给你发起 PR: 增加 GitLab 支持。你看到 PR 的代码有下面改进：</p>
<pre><code class="language-rust ignore">
// 增加了 Async Trait `IssueProvider` 来抽象 issues 接口
// 兼容 GitHub/Gitlab/Gitothers
trait IssueProvider {
    // 这个 issues 方法只需要遍历issues即可
    // 所以需要是一个实现AsyncIterator的类型
    async fn issues(&amp;mut self, url: &amp;str)
        -&gt; impl AsyncIterator&lt;Item = Result&lt;Issue, Err&gt;&gt;;
}

#[derive(Debug)]
struct Issue {
    number: usize,
    header: String,
    assignee: String,
}

// 使用独立的方法打印issues列表
// provider代表issues提供方是GitHub 还是 其他，比如 Gitlab
fn process_issues(provider: &amp;mut dyn IssueProvider) {
    for await? issue in provider.issues(&quot;https://github.com/rust-lang/rust&quot;) {
        if meets_criteria(&amp;issue) {
            println!(&quot;{issue:?}&quot;);
        }
    }
}
</code></pre>
<p>你合并了该 PR，一切OK。后面有人想将你的项目移植到 Chartreuse 操作系统，而 Chartreuse 操作系统是基于 Actor 模型的，并且有自己的自定义异步运行时。然而，你其实并不需要关心这些。因为你所有代码都能够无缝地将底层运行时实现切换到 Chartreuse 异步运行时。</p>
<p><strong>在 2022 年将要完成的目标</strong></p>
<p>看得出来，异步 Rust 在 2024 Edition 会更加的完善，使用起来更加方便。但是为了达到这个目标，2022年必须完成一些基础工作，并且可以预料到的是，在这个过程中，异步 Rust 的很多细节会发生大量变化，不出意外的话，生成器的语法应该会备受争议。但我们的整体愿景并不会改变：编写异步 Rust 代码应该像编写同步代码一样简单，除了偶尔出现的<code>async</code>和<code>await</code>关键字。</p>
<p>为此，Async 工作组组织成许多不同的计划，每个计划都在追求愿景的一部分：</p>
<ul>
<li><a href="https://rust-lang.github.io/async-fundamentals-initiative/">异步基础计划</a>，由 <a href="https://github.com/tmandry">tmandry</a>领导，聚焦于解决trait中支持<code>async fn</code>的难题。过去一年的工作：
<ul>
<li>协调和支持 <a href="https://rust-lang.github.io/generic-associated-types-initiative/"><code>GAT</code></a> 和 <a href="https://rust-lang.github.io/impl-trait-initiative/"><code>impl Trait</code></a> 计划。</li>
<li>起草 <a href="https://rust-lang.github.io/rfcs/3185-static-async-fn-in-trait.html">RFC #3185</a>，在 trait 中实现静态 <code>async fn</code>，用于支持静态分发，即，可以返回<code>impl Trait</code>。</li>
<li>致力于动态分发的设计，Niko 有一系列博文阐述相关内容：<a href="http://smallcultfollowing.com/babysteps//blog/2022/01/07/dyn-async-traits-part-7/">Dyn async traits</a>。</li>
<li>其他改进，比如<a href="https://tmandry.gitlab.io/blog/posts/2021-12-21-context-capabilities/">Contexts and capabilities in Rust</a>。</li>
</ul>
</li>
<li><a href="https://estebank.github.io/rust-iterator-item-syntax.html">异步迭代器计划</a>，由<a href="https://github.com/estebank">estebank</a>领导，探索生成器和异步生成器。Estebank 为生成器制作了一个程序宏的原型，并呼吁讨论语法和其他细节。</li>
<li><a href="https://www.ncameron.org/blog/portable-and-interoperable-async-rust/">可移植性计划</a>，在<a href="https://github.com/nrc">nrc</a>的带领下，<a href="https://www.ncameron.org/blog/portable-and-interoperable-async-rust/">探索如何让代码在运行时之间轻松移植</a>，从标准化的特征开始，例如<code>AsyncRead</code>和<code>AsyncWrite</code>。</li>
<li><a href="https://rust-lang.github.io/wg-async/vision/roadmap/polish.html">抛光打磨（Polish）计划</a>，由<a href="https://github.com/eholk">eholk</a>领导，专注于通过较小的变化来提高现有的能力，这些变化共同产生了巨大的影响。比如：
<ul>
<li><a href="https://github.com/rust-lang/rust/pull/91032">PR #91032</a>，改进生成器当变量在 <code>yield</code> 点之前被移动时的捕获分析。</li>
<li><a href="https://github.com/rust-lang/rust/pull/92508">PR #92508</a>，它生成了临时作用域的精确范围，进一步避免不必要的生成器捕获。</li>
<li><a href="https://github.com/guswynn">guswynn</a>提交了<a href="https://github.com/rust-lang/rust/pull/88865">PR #88865</a>，创建了 <code>must_not_suspend</code> lint，用于捕获一些不应该跨 <code>await</code> 存活的值。</li>
<li>开始研究 async stack traces 如何更加可读，更有帮助。</li>
</ul>
</li>
<li><a href="Q1/">工具计划</a>，由<a href="https://github.com/pnkfelix">pnkfelix</a>领导，致力于支持异步生态系统中那些正在创建有趣的工具来支持异步Rust的开发者们，诸如：
<ul>
<li>Michael Woerister正在探索<a href="https://github.com/rust-lang/async-crashdump-debugging-initiative">异步crashdump恢复</a>，提供一种机制来恢复和检查基于crashdump的异步Rust程序的状态。</li>
<li>Eliza Weisman和<a href="https://tokio.rs/blog/2021-12-announcing-tokio-console#thanks-to">其他许多人</a>最近宣布了他们0.1版本的<a href="https://github.com/tokio-rs/console"><code>tokio-console</code></a> （异步Rust程序的诊断和调试工具）。</li>
</ul>
</li>
</ul>
<p>上面这些计划都可以在 <a href="https://rust-lang.github.io/wg-async/vision/roadmap.html">roadmap</a> 中找到。</p>
<p><strong>你如何参与</strong></p>
<p>如果你想参与，最好的路线是先从「打磨抛光计划」开始，在其页面上有<a href="https://rust-lang.github.io/wg-async/vision/roadmap/polish.html#-how-to-help">&quot;如何帮助 &quot;部分</a>可以参考。</p>
<p><a href="https://blog.rust-lang.org/inside-rust/2022/02/03/async-in-2022.html">官方原文</a></p>
<h2 id="rust-2024-敢于要求更多"><a class="header" href="#rust-2024-敢于要求更多">Rust 2024 ：敢于要求更多</a></h2>
<p>Rust 语言团队 Leader Niko 在其博文上畅想 Rust 2024 Edition：</p>
<ul>
<li>敢于要求更符合人体工程学、更具表现力的 Rust</li>
<li>敢于要求更符合人体工程学、表现力更强的异步Rust</li>
<li>敢于要求更符合人体工程学、表现力更强的Unsafe Rust</li>
<li>敢于要求从 Rust 的工具中获得更丰富、更具交互性的体验</li>
<li>敢于为Unsafe Rust要求更丰富的工具</li>
</ul>
<p><a href="https://smallcultfollowing.com/babysteps//blog/2022/02/09/dare-to-ask-for-more-rust2024/">https://smallcultfollowing.com/babysteps//blog/2022/02/09/dare-to-ask-for-more-rust2024/</a></p>
<h2 id="rust-2022-编译器团队的雄心"><a class="header" href="#rust-2022-编译器团队的雄心">Rust 2022 编译器团队的雄心</a></h2>
<p><a href="https://blog.rust-lang.org/inside-rust/2022/02/22/compiler-team-ambitions-2022.html">https://blog.rust-lang.org/inside-rust/2022/02/22/compiler-team-ambitions-2022.html</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="社区热点"><a class="header" href="#社区热点">社区热点</a></h1>
<hr />
<h2 id="adacore-和-ferrous-systems-合作为-rust-工具链-ferrocene-认证各种安全标准"><a class="header" href="#adacore-和-ferrous-systems-合作为-rust-工具链-ferrocene-认证各种安全标准">AdaCore 和 Ferrous Systems 合作为 Rust 工具链 Ferrocene 认证各种安全标准</a></h2>
<p>AdaCore 与 Rust 编程语言专家公司 Ferrous Systems 建立了战略合作伙伴关系，以进一步开发 Ferrous Systems 的 Ferrocene （二茂铁）Rust 工具链，以支持嵌入式任务和安全关键应用程序，并使其符合相关行业软件安全标准。</p>
<p>在工业应用中，人们对 Rust 的兴趣和使用越来越多，但对于汽车、航空航天和国防等安全关键市场，目前还没有经过安全认证的 Rust 工具链。Ferrocene 合作伙伴关系将支持希望将新兴的 Rust 语言技术集成到其安全关键应用程序中的客户的认证需求。</p>
<blockquote>
<p>25 年来，AdaCore 通过投资新架构、语言和技术来支持安全和关键任务行业不断变化的需求。我们相信，在安全和安保关键领域都需要 Ada 和 Rust - AdaCore 产品管理和业务开发负责人 Quentin Ochem 如是说</p>
</blockquote>
<p>对于 Ferrous Systems 而言，Ferrocene 是一个利用 Rust 的技术专长和与 Rust 社区的关系将 Rust 转变为任务和安全关键嵌入式软件开发的关键位置的机会。</p>
<p>对于 AdaCore 而言，通过与 Ferrocene 的开发合作，它补充了公司对 Ada 的长期承诺，并提供了将在安全认证的 Ada 工具链开发中获得的专业知识扩展到 Rust 社区的机会。</p>
<p><a href="https://www.adacore.com/press/adacore-joins-forces-ferrous-systems-support-rust">https://www.adacore.com/press/adacore-joins-forces-ferrous-systems-support-rust</a></p>
<h2 id="出现首个用-rust-编写的勒索软件即服务raas"><a class="header" href="#出现首个用-rust-编写的勒索软件即服务raas">出现首个用 Rust 编写的勒索软件即服务(RaaS)</a></h2>
<p>2021 年 12 月，研究人员发现了一种名为ALPHV（又名“ BlackCat ”）的新型勒索软件即服务（RaaS, ransomware-as-a-service），它被认为是第一个创建和使用以Rust编程语言编写的勒索软件的专业网络犯罪组织。</p>
<p>以下是一些关键要点： </p>
<ul>
<li>该组织正在积极招募前 REvil、BlackMatter 和 DarkSide 运营商 </li>
<li>自 2021 年 11 月以来活动增加 </li>
<li>丰厚的会员支出（高达 90%） </li>
<li>基于 Rust 的勒索软件可执行文件（快速、跨平台、针对每个受害者进行大量定制） </li>
<li>默认 AES 加密 </li>
<li>内置权限提升（UAC 绕过、Masquerade_PEB、CVE-2016-0099） </li>
<li>可以通过 PsExec 传播到远程主机 </li>
<li>使用 VSS Admin 删除卷影副本 </li>
<li>停止 VMware ESXi 虚拟机并删除快照 </li>
</ul>
<p>与许多其他勒索软件威胁不同，ALPHV 是使用 Rust 开发的，Rust 是一种以其快速性能和跨平台功能而闻名的编程语言，导致在 2021 年 12 月和 2022 年 1 月期间观察到 Linux 和 Windows 变体。</p>
<p>尽管许多人认为 ALPHV 可能是第一个使用这种语言的“野外”勒索软件威胁，但Rust 勒索软件的<a href="https://github.com/cdong1012/Rust-Ransomware">概念验证已于 2020 年 6 月在 GitHub 上</a>发布，尽管没有任何迹象表明这两者有任何关系有关的。 </p>
<p>Catalin Cimpanu为The Record写道，更多恶意软件转向Rust的一个担忧是，与 C 和 C++ 相比，它被认为是一种更安全的编程语言。结果呢？安全防御者一直在寻找许多勒索软件中的编码弱点，如果更多人开始转向 Rust，那么找到这些弱点可能会变得更加困难。</p>
<p>最近观察到的 ALPHV 样本使用了 2021 年 11 月 4 日才发布的<a href="https://crates.io/crates/zeroize">Zeroize</a>版本 1.4.3，同时还使用了被 2021 年 11 月 16 日和 17 日发布的版本所取代的公钥加密版本。</p>
<p>虽然使用的许多 Rust crate 都有些明显，例如使用命令行界面和加密库，但使用 Zeroize（一个从内存中安全清除机密的库）似乎是故意尝试防止加密机密被泄露从受感染的主机中恢复。 </p>
<p><a href="https://krebsonsecurity.com/2022/01/who-wrote-the-alphv-blackcat-ransomware-strain/">https://krebsonsecurity.com/2022/01/who-wrote-the-alphv-blackcat-ransomware-strain/</a></p>
<h2 id="aws-rust-的可持续性"><a class="header" href="#aws-rust-的可持续性">AWS: Rust 的可持续性</a></h2>
<p><a href="https://aws.amazon.com/blogs/opensource/sustainability-with-rust/">https://aws.amazon.com/blogs/opensource/sustainability-with-rust/</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="学习资源"><a class="header" href="#学习资源">学习资源</a></h1>
<p>这里刊登了最近三个月值得学习的开源项目和博客文章等资源。</p>
<ul>
<li><a href="Q1/./learns/projects.html">开源项目</a></li>
<li><a href="Q1/./learns/blogs.html">博文教程</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="开源项目"><a class="header" href="#开源项目">开源项目</a></h1>
<p>值得学习的开源项目</p>
<hr />
<h2 id="type-exercise-in-rust-数据库表达式执行的黑魔法用-rust-做类型体操"><a class="header" href="#type-exercise-in-rust-数据库表达式执行的黑魔法用-rust-做类型体操">type-exercise-in-rust: 数据库表达式执行的黑魔法：用 Rust 做类型体操</a></h2>
<p>该项目通过在数据库系统中实现表达式框架来学习 Rust 黑魔法，围绕 Rust 程序员如何使用 Rust 编程语言构建数据库系统展开：利用 Rust 类型系统来最小化运行时成本，并使用安全的 Nightly Rust 使开发过程更容易。</p>
<p><a href="https://github.com/skyzh/type-exercise-in-rust">https://github.com/skyzh/type-exercise-in-rust</a></p>
<h2 id="jotsy-一个自托管免费和开源的笔记应用程序"><a class="header" href="#jotsy-一个自托管免费和开源的笔记应用程序">jotsy: 一个自托管、免费和开源的笔记应用程序</a></h2>
<p>后台基于 Rust / <a href="https://github.com/skytable/skytable">Skytable</a> / <a href="https://tokio.rs/">Tokio</a> / <a href="https://github.com/tokio-rs/axum">Axum</a> / <a href="https://github.com/djc/askama">Askama</a> 实现。前端就是纯 HTML、CSS 和 JavaScript 构建。</p>
<p>功能非常简单，可以基于该项目去扩展功能，也可以学习 Rust 使用。</p>
<ul>
<li><a href="https://github.com/ohsayan/jotsy">https://github.com/ohsayan/jotsy</a></li>
<li><a href="https://ohsayan.github.io/2022/02/jotsy-a-self-hosted-notes-app/">介绍文章</a></li>
</ul>
<h2 id="bevy-实现的扫雷游戏"><a class="header" href="#bevy-实现的扫雷游戏">bevy 实现的扫雷游戏</a></h2>
<ul>
<li><a href="https://dev.to/qongzi/series/16975">系列文章</a></li>
<li><a href="https://gitlab.com/qonfucius/minesweeper-tutorial">项目</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="博文教程"><a class="header" href="#博文教程">博文教程</a></h1>
<h2 id="rust-借用检查规则注定被打破"><a class="header" href="#rust-借用检查规则注定被打破">Rust 借用检查规则注定被“打破”</a></h2>
<p>这篇文章想表达的内容并不是真的要“打破”借用检查，它是提供了一个视角来介绍 <code>Rc/Arc/Cell/RefCell/Mutex/Atomics</code>等。</p>
<ul>
<li><a href="https://blog.warp.dev/rules-are-made-to-be-broken/">https://blog.warp.dev/rules-are-made-to-be-broken/</a></li>
<li><a href="https://www.reddit.com/r/rust/comments/t54pab/rusts_rules_are_made_to_be_broken/">Reddit 讨论</a></li>
</ul>
<h2 id="shaking-off-the-rust--系列-rust-学习博客"><a class="header" href="#shaking-off-the-rust--系列-rust-学习博客">Shaking off the Rust : 系列 Rust 学习博客</a></h2>
<p>通过实际构建东西，将在此过程中了解一系列技术概念，并提高 Rust 的能力。</p>
<p><a href="https://www.sotr.blog/">https://www.sotr.blog/</a></p>
<h2 id="nom-解析比特流"><a class="header" href="#nom-解析比特流">nom 解析比特流</a></h2>
<p>该文章介绍了如何使用 Nom v7 来解析二进制数据，比如 DNS 协议头。</p>
<p>在该文章相关的 Reddit 讨论中，有网友提出解析 DNS 协议头并不需要使用 nom，而利用位运算来提取相关部分是常规操作。并提供了一个库 <a href="https://github.com/tuffy/bitstream-io">bitstream-io</a>，提供了方便的接口来处理媒体编解码时候可能出现的一些位偏移问题。但作者使用nom是为了玩 <a href="https://adventofcode.com/">https://adventofcode.com/</a>，学习目的。</p>
<p>其他网页也给出了一些看法和库，了解细节可以看看 reddit 讨论。</p>
<p>当然，Rust 生态也有生产级的 DNS 解析库 : <a href="https://github.com/bluejekyll/trust-dns">trust-dns</a> 。</p>
<ul>
<li><a href="https://blog.adamchalmers.com/nom-bits/">https://blog.adamchalmers.com/nom-bits/</a></li>
<li><a href="https://www.reddit.com/r/rust/comments/t52iuz/parsing_bitstreams_with_nom/">https://www.reddit.com/r/rust/comments/t52iuz/parsing_bitstreams_with_nom/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="高校公开课"><a class="header" href="#高校公开课">高校公开课</a></h1>
<h2 id="斯坦福大学-cs110l"><a class="header" href="#斯坦福大学-cs110l">斯坦福大学 CS110L</a></h2>
<p>斯坦福大学CS110L，于2020年开设，b站有录播视频 : <a href="https://www.bilibili.com/video/BV1Ra411A7kN">https://www.bilibili.com/video/BV1Ra411A7kN</a></p>
<p>该课程持续开设，2020 和 2021 的课件是不一样的，2021 加了一节关于程序静态分析和动态分析的内容，2022年也继续。</p>
<ul>
<li><a href="https://reberhardt.com/cs110l/spring-2021/">2021 年</a></li>
<li><a href="https://web.stanford.edu/class/cs110l/">2022 年</a></li>
</ul>
<h2 id="kaist-cs431-concurrent-programming"><a class="header" href="#kaist-cs431-concurrent-programming">KAIST CS431: Concurrent Programming</a></h2>
<ul>
<li><a href="https://github.com/kaist-cp/cs431">https://github.com/kaist-cp/cs431</a></li>
<li><a href="https://docs.google.com/presentation/d/1NMg08N1LUNDPuMxNZ-UMbdH13p8LXgMM3esbWRMowhU/edit#slide=id.g419ba1421c_0_9">Slides</a></li>
<li><a href="https://www.youtube.com/watch?v=TTVuUIhdn_g&amp;list=PL5aMzERQ_OZ9j40DJNlsem2qAGoFbfwb4">Youtube</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="线上视频"><a class="header" href="#线上视频">线上视频</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="外刊评论"><a class="header" href="#外刊评论">外刊评论</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="学术动态"><a class="header" href="#学术动态">学术动态</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<h2 id="来自于-mit-pdos-的研究型项目-terra"><a class="header" href="#来自于-mit-pdos-的研究型项目-terra">来自于 MIT-PDOS 的研究型项目: terra</a></h2>
<p>一个用 Rust 编写的大型地形渲染库，基于 wgpu。</p>
<blockquote>
<p><a href="https://github.com/mit-pdos">https://github.com/mit-pdos</a></p>
</blockquote>
<p><a href="https://github.com/fintelia/terra">https://github.com/fintelia/terra</a></p>
<h2 id="清华大学-2022-全国大学生操作系统比赛"><a class="header" href="#清华大学-2022-全国大学生操作系统比赛">清华大学： 2022 全国大学生操作系统比赛</a></h2>
<p><a href="https://github.com/oscomp">https://github.com/oscomp</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly"><a class="header" href="#webassembly">WebAssembly</a></h1>
<h2 id="卡内基梅隆大学论文使用-webassembly-的可证明安全的多语言沙箱"><a class="header" href="#卡内基梅隆大学论文使用-webassembly-的可证明安全的多语言沙箱">卡内基梅隆大学论文：使用 WebAssembly 的可证明安全的多语言沙箱</a></h2>
<p>该论文探索了两种生成可证明wasm代码的方法：</p>
<ul>
<li>传统形式化方法生成数学的、经过机器检查的安全性证明。对应实现为 vWasm 编译器。</li>
<li>将 wasm 语义小心地嵌入到安全的 Rust 代码中，以便 Rust 编译器能够以良好的性能emit安全的可执行代码。对应实现为 rWasm 编译器。</li>
</ul>
<p>本文贡献：</p>
<ul>
<li>vWasm 是第一个经过验证的沙盒编译器，通过传统的机器检查证明实现。</li>
<li>rWasm 是第一个可证明安全的沙箱编译器，具有极具竞争力的运行时性能。通过利用 Rust 的安全保证，rWasm 实现了第一个多语言多平台的沙箱编译器。它是提供了可证明的保证，而无需编写正式的证明。</li>
</ul>
<p>rWasm 机制：</p>
<ul>
<li>编译策略：
<ol>
<li>通过一个编译前端将wasm编译为 IR</li>
<li>包括一个栈和死代码分析器</li>
<li>通过一个后端将 IR 打印为 Rust 代码</li>
<li>通过 rustc 编译器生成机器代码</li>
</ol>
</li>
<li>rWasm是通过 Safe Rust 实现的</li>
<li>rWasm的关键是： 通过将低级代码(Wasm)提升为高级代码（Rust）来完成对低级代码的仿真，从而得到高级语言的保证。因为想要证明的安全沙盒的高级属性本质就是内存安全。</li>
</ul>
<p><a href="https://www.jaybosamiya.com/publications/2022/usenix/provably-safe-sandboxing-wasm.pdf">https://www.jaybosamiya.com/publications/2022/usenix/provably-safe-sandboxing-wasm.pdf</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="开源动态"><a class="header" href="#开源动态">开源动态</a></h1>
<p>按领域记录 Rust 开源生态。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据处理"><a class="header" href="#数据处理">数据处理</a></h1>
<hr />
<h2 id="数据库"><a class="header" href="#数据库">数据库</a></h2>
<h3 id="skytable-高性能安全可靠的实时-nosql-数据库"><a class="header" href="#skytable-高性能安全可靠的实时-nosql-数据库">Skytable: 高性能、安全可靠的实时 NoSQL 数据库</a></h3>
<p>Skytable 致力于提供最好的 键值对(key/value) 存储、文档(document)存储和列式(columnar)数据库。Skytable 以前称为 TerrabaseDB（然后是 Skybase），也被社区昵称为“STable”、“Sky”和“SDB”。</p>
<p>Skytable 目前正在开发中，但可以用作高性能、安全和持久的键值存储。</p>
<ul>
<li><a href="https://github.com/skytable/skytable/issues/203">路线图</a></li>
<li><a href="https://skytable.io/">https://skytable.io/</a></li>
<li><a href="https://docs.skytable.io/">文档</a></li>
<li><a href="https://github.com/skytable/skytable">https://github.com/skytable/skytable</a></li>
</ul>
<h2 id="基础工具"><a class="header" href="#基础工具">基础工具</a></h2>
<h3 id="roaring-rs-更好的压缩位集bitset"><a class="header" href="#roaring-rs-更好的压缩位集bitset">roaring-rs: 更好的压缩位集（bitset）</a></h3>
<p><a href="https://arxiv.org/pdf/1402.6407v4.pdf">相关论文： 使用 Roaring bitmap 获得更好的位图性能</a> 中描述到：</p>
<blockquote>
<p>位图索引常用于数据库和搜索引擎。通过利用位级并行性，它们可以显着加速查询。但是，它们可以使用大量内存。因此我们可能更喜欢压缩位图索引。在 Oracle 的引领下，位图通常使用运行长度编码 (RLE) 进行压缩。在这项工作中，我们引入了一种新形式的压缩位图，称为 Roaring，它使用打包数组而不是 RLE 进行压缩。我们将其与两种基于 RLE 的高性能位图编码技术进行比较：WAH（字对齐混合压缩方案）和 Concise（压缩“n”可组合整数集）。在合成数据和真实数据上，我们发现 Roaring 位图通常压缩得更好。</p>
<p>Roaring 位图数据结构的 Rust 移植版本。位图（或位集）是一个二进制数组，我们可以将其视为整数集的有效且紧凑的表示。例如，集合和可能以二进制形式存储为 <code>10011000</code> 和<code>10110000</code>。我们可以使用位图（例如，在我们的例子中为<code>10111000</code>和<code>10010000</code>）上的按位运算（<code>OR</code>、<code>AND</code>）来计算两个这样的对应列表之间的并集或交集。</p>
<p>Roaring 将位图集条目作为 <code>32</code> 位整数存储在简洁的两级索引中。与两种有竞争力的位图压缩方案 WAH 和 Concise 相比，Roaring 使用的内存更少，速度更快。</p>
</blockquote>
<p>Roaring BitMap 简称为RBM，其实现思路：</p>
<p>将32位无符号整数按照高16位分桶，即最多可能有<code>2^16=65536</code>个桶，论文内称为container。存储数据时，按照数据的高16位找到container（找不到就会新建一个），再将低16位放入container中。也就是说，一个RBM就是很多container的集合。</p>
<blockquote>
<p>更多内容参考： https://www.jianshu.com/p/818ac4e90daf</p>
</blockquote>
<ul>
<li><a href="https://github.com/RoaringBitmap/roaring-rs">roaring-rs</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="云原生"><a class="header" href="#云原生">云原生</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="游戏与图像处理"><a class="header" href="#游戏与图像处理">游戏与图像处理</a></h1>
<h2 id="bevy-06-发布"><a class="header" href="#bevy-06-发布">Bevy 0.6 发布</a></h2>
<p>Bevy 目前还未稳定，所以版本更新会出现 break change的情况。升级需要看<a href="https://bevyengine.org/learn/book/migration-guides/0.5-0.6/">0.5 到 0.6 迁移指南</a>。</p>
<p>0.6 版本改进：</p>
<ul>
<li>一个全新的现代渲染器，更漂亮、更快速、更容易扩展</li>
<li>方向性和点状光影</li>
<li>集群式向前渲染</li>
<li>锥体裁剪剔除</li>
<li>以更少的模板大幅提高精灵的渲染速度</li>
<li>本地WebGL2支持。你可以在你的浏览器中运行Bevy的例子来测试这一点</li>
<li>更方便地自定义材质</li>
<li>更强大的着色器：预处理器、导入、WGSL支持</li>
<li>Bevy ECS的人机工程学和性能改进。不再有<code>.system()</code>!</li>
<li>健全性和正确性的改正。</li>
</ul>
<p><strong>重点摘要：ECS 改进</strong></p>
<p>Bevy ECS 的最优先准则是 人体工程学（ergonomics），即，开发体验要符合人类的习惯。Bevy 开发者们花了大量的精力来做到这一点。</p>
<ol>
<li>消除 system 方法调用</li>
</ol>
<p>这是 0.5 版本增加 System 的示例：</p>
<pre><code class="language-rust ignore">// This is a standalone Bevy 0.5 App that adds a simple `gravity` system to the App's schedule
// and automatically runs it in parallel with other systems
fn main() {
    App::build()
        .add_plugins(DefaultPlugins)
        .add_system(gravity.system())
        .run();
}

fn gravity(time: Res&lt;Time&gt;, mut query: Query&lt;&amp;mut Transform&gt;) {
    for mut transform in query.iter_mut() {
        transform.translation.y += -9.8 * time.delta_seconds();
    }
}
</code></pre>
<p>这是0.6的改进，完全去掉了 <code>.system()</code>。</p>
<pre><code class="language-rust ignore">// pure bliss!
App::new()
    .add_plugins(DefaultPlugins)
    .add_system(gravity) // 不需要调用 .system()
    .run();
</code></pre>
<ol start="2">
<li>改进组件trait和增加<code>#[derive(Component)]</code></li>
</ol>
<p>在Bevy 0.6中，类型不再默认实现 <code>Component</code> trait。在过去的版本中，通过下面这样一揽子（blanket impl）的实现为所有类型实现了 <code>Compont</code> trait 。</p>
<pre><code class="language-rust ignore">impl&lt;T: Send + Sync + 'static&gt; Component for T {}
</code></pre>
<p>但是在对Bevy ECS有深刻理解及对未来计划有很大变化之后，发现这样的设计存在以下问题：</p>
<ul>
<li>不是所有的东西都应该是组件。新用户不小心将捆绑类型和类型构造器添加为组件是在Bevy Discord上最常见的<code>#help channel threads</code>，这类错误是很难调试的。</li>
<li>如果我们对所有东西都自动实现了Component，我们就不能用相关的类型来定制Component类型。这就阻止了整类的优化。例如，Bevy ECS现在有多种Component存储类型。通过将存储类型移到Component中，我们使rustc能够优化通常需要在运行时进行的检查。</li>
<li>自动注册。将更多的逻辑转移到Component中，也使我们有能力在未来做更多的事情，比如 &quot;在派生Component时自动注册反射&quot;。</li>
<li>其他等，官网查看细节。</li>
</ul>
<p>现在可以通过派生宏自动实现，也可以手动实现 <code>Component</code>。</p>
<pre><code class="language-rust ignore">// defaults to &quot;Table&quot; storage
#[derive(Component)]
struct SomeComponent;

// overrides the default storage
#[derive(Component)]
#[component(storage = &quot;SparseSet&quot;)]
struct SomeComponent;
</code></pre>
<p><a href="https://bevyengine.org/news/bevy-0-6/">更多细节： https://bevyengine.org/news/bevy-0-6/</a></p>
<h2 id="vange-rs-是对一款具有独特玩法和技术创新的传奇游戏vange的rust重新实现"><a class="header" href="#vange-rs-是对一款具有独特玩法和技术创新的传奇游戏vange的rust重新实现">vange-rs: 是对一款具有独特玩法和技术创新的传奇游戏Vange的Rust重新实现</a></h2>
<p>该项目是由<a href="https://github.com/gfx-rs/wgpu-rs">wgpu-rs</a>作者 kvark 实现的。</p>
<p>技术栈：</p>
<p>该游戏使用<a href="https://github.com/gfx-rs/wgpu-rs">wgpu-rs</a>进行图形处理，使用<a href="https://github.com/tomaka/winit">winit</a>进行窗口化。</p>
<p>关卡是在单个全屏绘制调用中绘制的，带有一点光线追踪魔法。还有一个实验性的基于曲面细分的渲染器，但都没有产生足够质量的结果。请参阅渲染技术的<a href="https://github.com/kvark/vange-rs/wiki/Rendering-Techniques">专用 wiki 页面</a>。</p>
<p>注意：该项目依赖于原版游戏的素材，所以需要你自己在<a href="https://www.gog.com/game/vangers">GOG</a>购买该游戏（28元）才能跑，而且不支持 macosx m1。</p>
<ul>
<li><a href="https://github.com/kvark/vange-rs">https://github.com/kvark/vange-rs</a></li>
<li><a href="https://vange.rs/">https://vange.rs/</a></li>
</ul>
<h2 id="bevy-渐变动画插件发布新版本"><a class="header" href="#bevy-渐变动画插件发布新版本">Bevy 渐变动画插件发布新版本</a></h2>
<p><a href="https://github.com/djeedai/bevy_tweening">https://github.com/djeedai/bevy_tweening</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="操作系统"><a class="header" href="#操作系统">操作系统</a></h1>
<hr />
<h2 id="用-rust-实现的低级-ntfs-文件系统库"><a class="header" href="#用-rust-实现的低级-ntfs-文件系统库">用 Rust 实现的低级 NTFS 文件系统库</a></h2>
<p>NTFS是所有 Windows 版本中的主要文件系统（从 1993 年的 Windows NT 3.1 开始）。此板条箱适用于 Windows 2000 到当前 Windows 11 中使用的 NTFS 3.x 版本。</p>
<p>crate 是no_std兼容的，因此可用于从固件级代码到用户模式应用程序。</p>
<ul>
<li><a href="https://github.com/ColinFinck/ntfs">https://github.com/ColinFinck/ntfs</a></li>
<li><a href="https://fosdem.org/2022/schedule/event/misc_ntfs_rust/">https://fosdem.org/2022/schedule/event/misc_ntfs_rust/</a></li>
</ul>
<h2 id="rust-for-linux-第四次补丁提审"><a class="header" href="#rust-for-linux-第四次补丁提审">Rust for Linux 第四次补丁提审</a></h2>
<p>补丁的具体细节可以在Linux 邮件列表中找到：</p>
<ul>
<li>RFC: https://lore.kernel.org/lkml/20210414184604.23473-1-ojeda@kernel.org/</li>
<li>v1:  https://lore.kernel.org/lkml/20210704202756.29107-1-ojeda@kernel.org/</li>
<li>v2:  https://lore.kernel.org/lkml/20211206140313.5653-1-ojeda@kernel.org/</li>
<li>v3:  https://lore.kernel.org/lkml/20220117053349.6804-1-ojeda@kernel.org/</li>
</ul>
<p>第二次补丁改进摘要可参考：<a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_12/ref.html">Rust for Linux 源码导读 | Ref 引用计数容器</a>。</p>
<p><strong>第三次补丁改进摘要：</strong></p>
<ul>
<li>对 Rust 的支持有一些改进：
<ul>
<li>升级到 Rust 1.58.0</li>
<li>增加了自动检测来判断是否有合适的 Rust 可用工具链（<code>CONFIG_RUST_IS_AVAILABLE</code>，用于替换<code>HAS_RUST</code>）</li>
<li>移除<code>!COMPILE_TEST</code> </li>
<li>其他构建系统的改进</li>
<li>文档改进</li>
<li>需要的不稳定功能之一，<code>-Zsymbol-mangling-version=v0</code>，在 1.59.0 中变得稳定。另一个，“maybe_uninit_extra”，将在 1.60.0 中。</li>
</ul>
</li>
<li>对抽象和示例驱动程序的一些改进：
<ul>
<li>加了将在总线中使用的“IdArray”和“IdTable”，以允许驱动程序指定在编译时保证为零终止（zero-terminated）的设备 ID 表。</li>
<li>更新了 <code>amba</code> 以使用新的常量设备 ID 表支持。</li>
<li>初始通用时钟框架抽象。</li>
<li>平台驱动程序现在通过实现特质（trait）来定义。包括用于简化平台驱动程序注册的新宏和新示例/模板。</li>
<li><code>dev_*</code> 打印宏。</li>
<li><code>IoMem&lt;T&gt;</code> 的<code>{read,write}*_relaxed</code> 方法。</li>
<li>通过删除 <code>FileOpener</code> 来简化文件操作。</li>
<li>在驱动程序注册的参数中添加了“ThisModule”。</li>
<li>添加用 Rust 编写的树外 Linux 内核模块的基本模板： [https ://github.com/Rust-for-Linux/rust-out-of-tree-module](https ://github.com/Rust-for-Linux/rust-out-of-tree-module)</li>
</ul>
</li>
</ul>
<p><strong>第四次补丁改进摘要：</strong></p>
<ul>
<li>基础设施更新：
<ul>
<li>整合 CI : 英特尔 0DAY/LKP 内核测试机器人 / kernelCI/ GitHub CI</li>
<li>内核模块不需要写 crate 属性，<code>#![no_std]</code> 和 <code>#![feature(...)]</code> 不再存在，删除样板。</li>
<li>添加了单目标支持，包括<code>.o</code>、<code>.s</code>、<code>.ll</code>和<code>.i</code>（即宏扩展，类似于 C 预处理源）。</li>
<li>对<code>helpers.c</code>文件的解释和对helpers的许可和导出的许可。</li>
<li>文档Logo现在基于矢量 (SVG)。此外，已经为上游提出了 Tux 的矢量版本，并且用于改进自定义Logo支持的 RFC 已提交至上游 Rust。</li>
<li>添加了关于注释 (<code>//</code>) 和代码文档的编码指南(<code>///</code>)。</li>
<li><code>is_rust_module.sh</code> 返工。</li>
<li>现在跳过了叶子模块的<code>.rmeta</code>的生成。</li>
<li>其他清理、修复和改进。</li>
</ul>
</li>
<li>抽象和驱动更新:
<ul>
<li>
<p>增加了对静态（全局共享变量）同步原语的支持。<code>CONFIG_CONSTRUCTORS</code>被用于实现。</p>
</li>
<li>
<p>通过使用标记类型简化了锁防护，即<code>Guard</code>和<code>GuardMut</code>统一为一个参数化的类型。如果标记是 <code>WriteLock</code>，那么 <code>Guard</code>就会实现<code>DerefMut</code>（以前只由<code>GuardMut</code>实现）。</p>
</li>
<li>
<p>可选参数添加到杂项设备（misc device）的注册中。遵循构建者模式，例如:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>miscdev::Options::new()
    .mode(0o600)
    .minor(10)
    .parent(parent)
    .register(reg, c_str!(&quot;sample&quot;), ())
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>增加了 &quot;RwSemaphore &quot;的抽象，该抽象包裹了C端<code>struct rw_semaphore</code>。</p>
</li>
<li>
<p>新的<code>mm</code>模块和VMA抽象（包装C端<code>struct vm_area_struct</code>）用于<code>mmap</code>。</p>
</li>
<li>
<p>GPIO PL061现在使用最近增加的<code>dev_*!</code> Rust宏。</p>
</li>
<li>
<p>支持<code>！CONFIG_PRINTK</code>情况。</p>
</li>
<li>
<p>其他清理、修复和改进。</p>
</li>
</ul>
</li>
</ul>
<h2 id="kerla用-rust-编写的具有-linux-abi-兼容性的新操作系统内核"><a class="header" href="#kerla用-rust-编写的具有-linux-abi-兼容性的新操作系统内核">kerla：用 Rust 编写的具有 Linux ABI 兼容性的新操作系统内核</a></h2>
<p>Kerla 是一个用 Rust 从头开始​​编写的操作系统内核，旨在与 Linux ABI 兼容，也就是说，它无需任何修改即可运行 Linux 二进制文件。</p>
<ul>
<li>
<p>实现 *NIX 进程概念：上下文切换、信号<code>fork(2)</code>、<code>execve(2)</code>、<code>wait4(2)</code>等。</p>
</li>
<li>
<p>支持常用的系统调用，如<code>write(2)</code>, <code>stat(2)</code>, <code>mmap(2)</code>, <code>pipe(2)</code>, <code>poll(2)</code>, ...</p>
</li>
<li>
<p>目前不支持磁盘：<code>initramfs</code> 被挂载为根文件系统。</p>
</li>
<li>
<p>伪文件系统：<code>tmpfs</code> 和 <code>devfs</code>。</p>
</li>
<li>
<p>基于<code>smoltcp</code>的 TCP/IP 支持。</p>
</li>
<li>
<p>实现 <code>tty</code> 和伪终端 (pty)。</p>
</li>
<li>
<p>支持 QEMU 和 Firecracker（带有 virtio-net 设备驱动程序）。</p>
</li>
<li>
<p>支持 x86_64。</p>
</li>
<li>
<p>基于 Docker 的 initramfs 构建系统。</p>
</li>
<li>
<p><a href="https://kerla.dev/">https://kerla.dev/</a></p>
</li>
<li>
<p><a href="https://github.com/nuta/kerla">https://github.com/nuta/kerla</a></p>
</li>
<li>
<p><a href="https://seiya.me/writing-linux-clone-in-rust">Writing a Linux-compatible kernel in Rust</a></p>
</li>
</ul>
<h2 id="snarkos-去中心化操作系统"><a class="header" href="#snarkos-去中心化操作系统">snarkOS: 去中心化操作系统</a></h2>
<p>snarkOS是一个用于私有应用程序的去中心化操作系统。它构成了<a href="https://aleo.org/">Aleo</a>的主干，使应用程序能够以可公开验证的方式验证和存储状态。</p>
<p><a href="https://github.com/AleoHQ/snarkOS">https://github.com/AleoHQ/snarkOS</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命令行工具"><a class="header" href="#命令行工具">命令行工具</a></h1>
<h2 id="adsb_deku-rust-实现的终端雷达应用"><a class="header" href="#adsb_deku-rust-实现的终端雷达应用">adsb_deku： Rust 实现的终端雷达应用</a></h2>
<p>基于 tui-rs，实现在终端即可解码 ADS-B 来监视飞越你家的飞机</p>
<blockquote>
<p>ADS-B : 广播式自动相关监视</p>
</blockquote>
<p>“ADS-B 是一种空中交通监视应用，用于传递飞行参数，比如，位置，航迹和
地速等，通过数据链广播模式，在特定的间隔时间内发送，任何空地用户
都可以申请使用这个功能。” (ICAO国际民航组织)</p>
<ul>
<li>ADS-B RAD : 广播式自动相关监视 可用于雷达覆盖空域</li>
<li>ADS-B NRA : 广播式自动相关监视 可用于无雷达覆盖空域</li>
<li>ADS-B APP : 广播式自动相关监视 可用于机场地面活动区交通监视</li>
</ul>
<p><a href="https://github.com/rsadsb/adsb_deku">https://github.com/rsadsb/adsb_deku</a></p>
<h2 id="cargo-mobile-帮助你在-ios-和-andriod-上方便地使用-rust"><a class="header" href="#cargo-mobile-帮助你在-ios-和-andriod-上方便地使用-rust">cargo-mobile: 帮助你在 iOS 和 Andriod 上方便地使用 Rust</a></h2>
<p>这个工具是对 “如何在 iOS 和 Andriod 上使用 Rust ？” 问题的回应。</p>
<p>cargo-mobile 是一个与框架无关的工具，可以生成 Xcode 和 Android Studio 项目文件、在设备上构建和运行、生成项目样板文件以及其他一些事情！目前支持 macOS 和 Linux 。</p>
<p>该工具在 BrainiumLLC 公司内部已经使用了，可以看其<a href="https://dev.brainiumstudios.com/2020/11/24/cargo-mobile.html">公司博客介绍</a>。注意，这篇文章是两年前的了，但是工具是刚开源，文章还未来得及更新。</p>
<pre><code class="language-sh">cargo install --git https://github.com/BrainiumLLC/cargo-mobile
</code></pre>
<p><a href="https://github.com/BrainiumLLC/cargo-mobile">https://github.com/BrainiumLLC/cargo-mobile</a></p>
<h2 id="argc-一种处理-shbash-命令参数的便捷方式"><a class="header" href="#argc-一种处理-shbash-命令参数的便捷方式">argc: 一种处理 <code>sh/bash</code> 命令参数的便捷方式</a></h2>
<pre><code class="language-sh"># demo.sh

# @describe A demo cli

# @cmd Upload a file
# @arg target!                      File to upload
upload() {
    echo &quot;cmd                       upload&quot;
    echo &quot;arg:  target              $argc_target&quot;
}

# @cmd Download a file
# @flag     -f --force              Override existed file
# @option   -t --tries &lt;NUMBER&gt;     Set number of retries to NUMBER
# @arg      source!                 Url to download from
# @arg      target                  Svae file to
download() {
    echo &quot;cmd:                      download&quot;
    echo &quot;flag:   --force            $argc_force&quot;
    echo &quot;option: --tries           $argc_tries&quot;
    echo &quot;arg:    source            $argc_source&quot;
    echo &quot;arg:    target            $argc_target&quot;
}

eval &quot;$(argc -e $0 &quot;$@&quot;)&quot;
</code></pre>
<p>用 Argc 编写命令行程序，只需要做两件事：</p>
<ul>
<li>在注释中描述选项、参数和子命令</li>
<li>调用<code>eval</code>命令委托Argc为我们处理命令行参数</li>
</ul>
<p>Argc 根据标签（<code>@</code>注释中标记的字段）生成解析规则和帮助文档。</p>
<p><a href="https://github.com/sigoden/argc">https://github.com/sigoden/argc</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web-开发"><a class="header" href="#web-开发">Web 开发</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网络基建"><a class="header" href="#网络基建">网络基建</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web开发"><a class="header" href="#web开发">Web开发</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前端"><a class="header" href="#前端">前端</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="音视频处理"><a class="header" href="#音视频处理">音视频处理</a></h1>
<hr />
<h2 id="gyroflow-可以根据来自陀螺仪和可选的加速度计的运动数据来稳定视频"><a class="header" href="#gyroflow-可以根据来自陀螺仪和可选的加速度计的运动数据来稳定视频">gyroflow: 可以根据来自陀螺仪和可选的加速度计的运动数据来稳定视频</a></h2>
<p>现代相机在内部记录这些数据（GoPro、Sony、Insta360 等），并且此应用程序通过使用它们来精确稳定捕获的镜头。它还可以使用来自外部源（例如来自 Betaflight blackbox）的陀螺仪数据。</p>
<p>用它可以省下买大疆手持稳定器的钱？</p>
<p>支持的陀螺源：</p>
<ul>
<li>GoPro（HERO 5 及更高版本）</li>
<li>索尼（a1、a6600、a7c、a7r IV、a7 IV、a7s III、a9 II、FX3、FX6、RX0 II、RX100 VII、ZV1、ZV-E10）</li>
<li>Insta360 (OneR, SMO 4k, GO2)</li>
<li>Betaflight 黑盒（CSV 和二进制）</li>
<li>移动应用程序：Sensor Logger, G-Field Recorder,Gyro</li>
<li>Runcam CSV（Runcam 5 橙色，iFlight GOCam GR）</li>
<li>WitMotion（WT901SDCL 二进制文件和 *.txt）</li>
</ul>
<p>支持Windows 10 64 位（1809 或更高版本）/ macOS 10.14 或更高版本（本机支持 Intel 和 Apple Silicon）/ Linux / 安卓9 等，具体请参考该项目仓库README文档。</p>
<p>技术栈：FFmpeg/QT/Wgpu/OpenGL/OpenCV</p>
<ul>
<li><a href="https://gyroflow.xyz/">官网</a></li>
<li><a href="https://github.com/gyroflow/gyroflow">https://github.com/gyroflow/gyroflow</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基于rust的新编程语言"><a class="header" href="#基于rust的新编程语言">基于Rust的新编程语言</a></h1>
<h2 id="hvm-基于-rust-实现的用于大规模并行的最佳函数式运行时"><a class="header" href="#hvm-基于-rust-实现的用于大规模并行的最佳函数式运行时">HVM: 基于 Rust 实现的用于大规模并行的最佳函数式运行时</a></h2>
<p>HVM 全称 High-order Virtual Machine，高阶虚拟机，虽然只是一个原型，但性能优于 Haskell 的 GHC。HVM 的核心是一种非常简单的语言，类似于无类型的 Haskell。</p>
<p>HVM 采用最新的计算模型，即交互网络（Interaction Net）。该计算模型是图灵机（Turing Machine）和Lambda演算（Lambda Calculus）的结合，该模型的先前实现在实践中效率低下，然而，最近的一项突破大大提高了其效率，催生了 HVM。尽管是一个原型，但它在许多情况下已经击败了成熟的编译器，并且将朝着未知的性能水平扩展。</p>
<p>HVM 的运行时没有引用。相反，它具有一个<code>.clone()</code>成本为零的原语，直到需要时才会读取Clone的值（Lazy）。一旦完成，它不会被整个复制，而是逐层按需完成。换句话说，可以把 HVM 看作是一个将借用检查换做低成本Clone的 Rust。</p>
<p>特点：</p>
<ul>
<li>
<p>Lazy</p>
</li>
<li>
<p>non-garbage-collected </p>
</li>
<li>
<p>massively parallel</p>
</li>
<li>
<p><a href="https://github.com/Kindelia/HVM">HVM</a></p>
</li>
<li>
<p><a href="https://www.researchgate.net/publication/220054026_Interaction_nets_programming_language_design_and_implementation">交互网络相关论文</a></p>
</li>
<li>
<p>作者相关的其他编程语言 <a href="https://github.com/yatima-inc/yatima">yatima</a></p>
</li>
</ul>
<h2 id="frawk-高效的类-awk-语言"><a class="header" href="#frawk-高效的类-awk-语言">frawk: 高效的类 awk 语言</a></h2>
<p>frawk 是一种小型编程语言，用于编写处理文本数据的短程序。大致上，它是 AWK语言的一种实现。</p>
<p>类似于 awk：</p>
<pre><code>awk - F','' NR &gt; 1 { SUM += $2 } END { print SUM }'
</code></pre>
<p>这段代码可以对文件中的第二列求和：</p>
<pre><code>Item,Quantity
Carrot,2
Banana,4
</code></pre>
<p>但是 frawk 性能更高。</p>
<ul>
<li><a href="https://github.com/ezrosent/frawk">https://github.com/ezrosent/frawk</a></li>
<li><a href="https://github.com/ezrosent/frawk/blob/master/info/overview.md">介绍</a></li>
</ul>
<h2 id="leo-lang-用于零知识应用的函数式静态类型语言"><a class="header" href="#leo-lang-用于零知识应用的函数式静态类型语言">leo-lang: 用于零知识应用的函数式、静态类型语言</a></h2>
<p>该语言被用于专门构建私有应用程序。是 <a href="https://aleo.org">aleo</a> 公司出品，配合该公司开源的去中心化操作系统 <a href="https://github.com/AleoHQ/snarkOS">snarkOS</a>。</p>
<p><a href="https://github.com/AleoHQ/leo">https://github.com/AleoHQ/leo</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="嵌入式rust"><a class="header" href="#嵌入式rust">嵌入式Rust</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="信息安全"><a class="header" href="#信息安全">信息安全</a></h1>
<hr />
<h2 id=""><a class="header" href="#"></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="科学艺术"><a class="header" href="#科学艺术">科学艺术</a></h1>
<hr />
<h2 id="生物信息学"><a class="header" href="#生物信息学">生物信息学</a></h2>
<blockquote>
<p>什么是生物信息学？</p>
<p>生物信息学是信息与系统科学和生命科学高度交叉的前沿学科，是自动化学科群中的重要部分，包括计算生物学、系统生物学与合成生物学等方向。生物信息学涉及多个学科领域，信息、控制与系统的理论、方法和技术在其中发挥着重要作用，同时，它也把控制科学与工程的研究对象从机械、电子、物理、化学等系统扩展到了以分子和细胞为基本元件的生命系统。</p>
<ul>
<li>生物信息学中计算机和大数据各扮演什么样的角色？ https://www.zhihu.com/question/21476539</li>
<li>生物信息学学科发展报告 https://zhuanlan.zhihu.com/p/47508742</li>
</ul>
</blockquote>
<h3 id="flopp-用于基因定相的rust实现的软件"><a class="header" href="#flopp-用于基因定相的rust实现的软件">flopp: 用于基因定相的Rust实现的软件</a></h3>
<p>用于从长读长测序中对多倍体生物进行单个单倍体定相。定相（Phasing）包括将每个染色体的父本母本遗传的拷贝分离成单倍型，以获得遗传变异的完整图谱。</p>
<p>定相在研究遗传变异领域非常重要，定相算法本身基本都是计算密集型的，做起来也比较耗时间，有时即使是在超算集群中也得跑很长时间。所以，Rust 语言应该是非常适合该场景。</p>
<p>flopp 非常快，多线程，并且完全用 rust 编程语言编写。与其他多倍体单倍体定相算法相比，flopp 提供了一个数量级的加速和更好的准确性。</p>
<blockquote>
<p>什么是 定相（Phasing）？</p>
<p>Phasing，或者说Genotype Phasing，它的中文名有很多：基因定相、基因分型、单倍体分型、单倍体构建等在不同的语境下都有人说过。但不管如何，所谓Phasing就是要把一个二倍体（甚至是多倍体）基因组上的等位基因（或者杂合位点），按照其亲本正确地定位到父亲或者母亲的染色体上，最终使得所有来自同一个亲本的等位基因都能够排列在同一条染色体里面。</p>
<p>现在流行的NGS测序技术，都是把序列打乱混在一起测序的，测完之后，我们是无法直接区分这些序列中哪一个是父源，哪一个是母源的。我们通常都只是检测出基因组上有哪些变异，以及这些变异的碱基组成（纯合、杂合），也就是平时所说的基因型（Genotype）。只有经过Phasing，才能够实现这个区分。</p>
<p>为什么要Phasing ?</p>
<p>因为Phasing很重要。Phasing的重要性可以分为两个方面。</p>
<p>一方面, Phasing与遗传变异的功能诠释密切相关。这体现在遗传咨询师或者科学家需了解基因突变的相位后, 才能更好地判断基因突变是否会产生临床表型。比如在一个基因上发生多个Loss of function variants(LOF)，通常当这些变异出于不同的单倍型时(这称为trans-configuration)，即两个拷贝的姐妹基因都发生了变异, 才会导致基因表达计量(Gene expression dosage)的错误且产生危害。而当它们出于同一个单倍型时(这称为cis-configuration)，因为还有一个正常拷贝的基因（作为备胎）, 基因表达很可能不会发生改变也不会产生危害。</p>
<p>另一方面, Phasing在遗传学研究中也有诸多应用，具体如下：</p>
<ul>
<li>第一、人群Phasing后形成的单倍型参考序列集(Reference panel)是基因型推断（Imputation）必须的数据材料。而基因型推断（Imputation）是基因型-表型关联分析研究中必不可少的环节。高质量的Reference Panel能提升关联分析的统计功效；</li>
<li>第二、除了Reference Panel的制造需要使用Phasing技术之外，对被研究的对象进行预先Phasing(Pre-phasing)也可以极大地提高基因型推断（Imputation）的准确性；</li>
<li>第三、使用多个位点组成的Haplotype，而不是简单的单位点基因型, 可实现群体遗传历史的推断；</li>
<li>第四、可通过Phased后的家系人群单倍型序列，估算染色体重组率、重组热点等重要遗传参数；</li>
<li>第五、Phasing可用于探测频发突变、选择信号以及基因表达的顺势调控。</li>
</ul>
<p>Phasing说起来容易，做起来却很难</p>
<p>虽然Phasing理解起来并不难，但实现起来却不容易，即使在理论上也是如此。这需要相关的统计学和计算机算法技术，求解的过程往往还是一个NP问题。目前通常采用马尔科夫链蒙特卡洛算法来完成，因此，Phasing算法本身基本都是计算密集型的，做起来也比较耗时间，有时即使是在超算集群中也得跑很长时间。</p>
<p>详细：<a href="https://zhuanlan.zhihu.com/p/36289359">https://zhuanlan.zhihu.com/p/36289359</a></p>
</blockquote>
<p><a href="https://github.com/bluenote-1577/flopp">https://github.com/bluenote-1577/flopp</a></p>
<h3 id="alevin-fry-高效灵活的单细胞测序数据处理工具"><a class="header" href="#alevin-fry-高效灵活的单细胞测序数据处理工具">alevin-fry: 高效灵活的单细胞测序数据处理工具</a></h3>
<p>alevin-fry是一套工具，用于快速、准确和节省内存地处理单细胞和单核测序数据。</p>
<p>该套工具是马里兰大学<a href="https://combine-lab.github.io/">计算生物学和网络进化实验室</a>开源的。该实验室的 GitHub 组织下还有其他的计算生物学相关的 Rust 库。</p>
<blockquote>
<p>背景
单细胞测序技术将伴随着高通量技术给临床以及学术界带来新的革命。理解单细胞水平的遗传信息异质性，为我们理解遗传、发育、疾病机理打开了新的大门。
参考： https://www.plob.org/article/22832.html</p>
</blockquote>
<p><a href="https://github.com/COMBINE-lab/alevin-fry">https://github.com/COMBINE-lab/alevin-fry</a></p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="其他工具"><a class="header" href="#其他工具">其他工具</a></h1>
<h2 id="lapce-发布-009-版本"><a class="header" href="#lapce-发布-009-版本">lapce 发布 0.0.9 版本</a></h2>
<p>lapce 是一款受 Xi-Editor 启发的编辑器，类似于 vscode。作者声称，他对 lapce 抱有雄心壮志，希望有朝一日可以和 VScode 竞争。</p>
<p>目标：</p>
<ul>
<li>启动迅速，基于 Rust + Druid 开发，使用 wgpu 渲染。</li>
<li>支持远程开发</li>
<li>支持 LSP，支持代码智能提示、诊断等</li>
<li>Vim 模式支持</li>
<li>WASI 插件系统</li>
<li>内置终端</li>
</ul>
<p>目前为 0.0.9 版本，看起来还不太完善，可以先关注。</p>
<ul>
<li><a href="https://lapce.dev/">https://lapce.dev/</a></li>
<li><a href="https://www.reddit.com/r/rust/comments/t550wy/lapce_open_source_code_editor_inspired_by_xieditor/">Reddit 相关讨论</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安全动态"><a class="header" href="#安全动态">安全动态</a></h1>
<p>记录 Rust 生态中的安全问题</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsound"><a class="header" href="#unsound">Unsound</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory"><a class="header" href="#memory">Memory</a></h1>
<h2 id="rustsec-2022-0012-arrow2-在-safe-代码中出现双重释放double-free"><a class="header" href="#rustsec-2022-0012-arrow2-在-safe-代码中出现双重释放double-free">RUSTSEC-2022-0012: Arrow2 在 Safe 代码中出现双重释放（double-free）</a></h2>
<ul>
<li><a href="https://github.com/jorgecarleitao/arrow2/issues/880">https://github.com/jorgecarleitao/arrow2/issues/880</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2022-0012.html">https://rustsec.org/advisories/RUSTSEC-2022-0012.html</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="商业动态"><a class="header" href="#商业动态">商业动态</a></h1>
<h2 id="transactional-storage-framework-sap-也在尝试使用-rust"><a class="header" href="#transactional-storage-framework-sap-也在尝试使用-rust">transactional-storage-framework： SAP 也在尝试使用 Rust</a></h2>
<p>在 SAP 的 GitHub 组织下有一个 事务存储框架（transactional-storage-framework） 项目，其开发者个人名下也有另一个 Rust 项目 scalable-concurrent-containers 。</p>
<p>事务存储框架是一个软件框架，为一个完整的事务存储系统提供关键操作接口和基本功能。Container类似于数据库管理软件中的数据库表。它的数据是根据嵌入在容器中的元数据组织的。容器是分层管理的，可以用字符串唯一标识。</p>
<ul>
<li><a href="https://github.com/SAP/transactional-storage-framework">https://github.com/SAP/transactional-storage-framework</a></li>
<li><a href="https://github.com/wvwwvwwv/scalable-concurrent-containers">https://github.com/wvwwvwwv/scalable-concurrent-containers</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="生产实践"><a class="header" href="#生产实践">生产实践</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="优秀产品"><a class="header" href="#优秀产品">优秀产品</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="区块链"><a class="header" href="#区块链">区块链</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-开发基础库"><a class="header" href="#rust-开发基础库">Rust 开发基础库</a></h1>
<hr />
<h2 id="deser-一个新的实验性-rust-序列化库"><a class="header" href="#deser-一个新的实验性-rust-序列化库">deser: 一个新的实验性 Rust 序列化库</a></h2>
<p>它想探索 JSON 或 msgpack 等结构化格式的序列化和反序列化的可能性。但不会支持 bincode 这种非自描述格式(non self describing formats)。</p>
<blockquote>
<p>自描述格式包含描述消息格式和含义的数据和元数据</p>
</blockquote>
<p><strong>设计目标：</strong></p>
<ul>
<li>快速编译时间： deser 通过鼓励动态分发来避免过度的单态化。</li>
<li>无限递归：现实世界很糟糕，传入的数据可能嵌套严重。无论数据有多深，都不能耗尽调用堆栈。</li>
<li>简单数据模型： deser 简化了序列化和反序列化接口上的数据模型，但通过提供描述符来弥补，这些描述符为序列化程序想要处理它时提供辅助信息。</li>
<li>可扩展数据模型： deser 希望能够使用非序列化接口原生的类型来扩展数据模型。例如，如果数据格式想要支持任意大小的整数，这应该是可能的，而无需退回到带内信令。</li>
<li>元信息： deser 通过提供保存元信息的空间来补偿简化的数据模型。</li>
<li>本机字节序列化： deser 具有内置的专门化功能，用于将字节和字节向量序列化为与切片和向量不同的格式。</li>
</ul>
<p><a href="https://github.com/mitsuhiko/deser">deser</a></p>
<h2 id="实验性diplomat-用于生成-ffi-定义的工具"><a class="header" href="#实验性diplomat-用于生成-ffi-定义的工具">【实验性】diplomat: 用于生成 FFI 定义的工具</a></h2>
<p>使用 Diplomat，您可以简单地定义要通过 FFI 公开的 Rust API，并自动获得高级 C、C++ 和 JavaScript 绑定！</p>
<ul>
<li><a href="https://github.com/rust-diplomat/diplomat">https://github.com/rust-diplomat/diplomat</a></li>
<li><a href="https://rust-diplomat.github.io/book/">https://rust-diplomat.github.io/book/</a></li>
</ul>
<h2 id="clap-31-发布"><a class="header" href="#clap-31-发布">Clap 3.1 发布</a></h2>
<p>Clap v3 开发了好几年，并且经过几次维护者变更，所以变更日志已经变得不再连续完整。</p>
<p>v3 最大的改变是集成了 <a href="https://docs.rs/structopt/">StructOpt</a>。</p>
<p><a href="https://github.com/clap-rs/clap/blob/master/CHANGELOG.md">https://github.com/clap-rs/clap/blob/master/CHANGELOG.md</a></p>
<h2 id="deku--声明式二进制读写"><a class="header" href="#deku--声明式二进制读写">deku : 声明式二进制读写</a></h2>
<p>为结构体和枚举提供位级（bit-level）、置换（symmetric）、序列化/反序列化实现。支持 <code>no_std</code> 和  <code>wasm</code>。</p>
<p><a href="https://github.com/sharksforarms/deku">https://github.com/sharksforarms/deku</a></p>
<h2 id="nextest--rust-的下一代测试执行器"><a class="header" href="#nextest--rust-的下一代测试执行器">nextest : Rust 的下一代测试执行器</a></h2>
<p>特点：</p>
<ul>
<li>干净美观的用户界面</li>
<li>比 <code>cargo test</code>性能快 <code>60%</code></li>
<li>自动重试失败的测试，如果稍后通过测试，就能将其标记为 不可靠测试（<code>flaky</code>），对于发现系统中的问题比较有用</li>
<li>分区测试跨多个 CI Jobs运行。如果您的测试在 CI 中运行的时间过长，nextest 可以自动为您将它们拆分到多个Jobs中。</li>
<li>跨平台。nextest 可在 Unix、Mac 和 Windows 上运行，因此无论您使用什么平台，您都可以获得更快的测试运行的好处。</li>
<li>其他（还在完善中）</li>
</ul>
<blockquote>
<p>不可靠测试（Flaky Tests），就是指在被测对象和测试条件都不变的情况下，有时候失败、有时候成功的测试。产生这类测试的原因包括：异步等待、并发、资源泄漏、远程服务、依赖其他测试、平台依赖性、系统时间、随机数等。
相关论文：<a href="https://www.cs.cornell.edu/courses/cs5154/2021sp/resources/LuoETAL14FlakyTestsAnalysis.pdf">https://www.cs.cornell.edu/courses/cs5154/2021sp/resources/LuoETAL14FlakyTestsAnalysis.pdf</a></p>
</blockquote>
<ul>
<li><a href="https://github.com/nextest-rs/nextest">https://github.com/nextest-rs/nextest</a></li>
<li><a href="https://nexte.st/index.html">nextest book</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="优秀投稿"><a class="header" href="#优秀投稿">优秀投稿</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="datenlord--rust原子类型和内存排序"><a class="header" href="#datenlord--rust原子类型和内存排序">DatenLord | Rust原子类型和内存排序</a></h1>
<p>作者：潘政</p>
<h2 id="简介"><a class="header" href="#简介">简介</a></h2>
<p>原子类型在构建无锁数据结构，跨线程共享数据，线程间同步等多线程并发编程场景中起到至关重要的作用。本文将从Rust提供的原子类型和原子类型的内存排序问题两方面来介绍。</p>
<h2 id="rust原子类型"><a class="header" href="#rust原子类型">Rust原子类型</a></h2>
<p>Rust标准库提供的原子类型在<a href="https://doc.rust-lang.org/std/sync/atomic/index.html">std::sync::atomic</a>模块下。Rust提供了AtomicBool, AtomicU8, AtomicU16, AtomicUsize等原子类型。下面我们以AtomicUsize为例介绍原子类型提供的原子操作。基本的load，store， swap原子操作就不过多介绍了。第一个要介绍的就是重要的compare-and-swap(CAS)原子操作，绝大部分无锁数据结构都或多或少依赖CAS原子操作。Rust提供的compare_and_swap接口如下：</p>
<pre><code class="language-Rust">pub fn compare_and_swap(&amp;self,
    current: usize,
    new: usize,
    order: Ordering
) -&gt; usize
</code></pre>
<p>compare_and_swap接受一个期望的值和一个新的值，这里我们先忽略掉Ordering，后面会详细介绍，如果变量的值等于期望的值，就将变量值替换成新的值返回成功，否则不做任何修改并返回失败。compare_and_swap从语义上包含了读(load)语义和写(store)语义，先读出变量的值，和期望值比较，然后写入内存。原子操作保证了这三个步骤是原子的，在三个步骤之间不会插入其他指令从而导致变量值被修改。从1.50.0开始compare_and_swap被deprecated了，现在需要使用compare_exchange和compare_exchange_weak接口来实现CAS原子操作。</p>
<pre><code class="language-Rust">pub fn compare_exchange(
    &amp;self,
    current: usize,
    new: usize,
    success: Ordering,
    failure: Ordering
) -&gt; Result&lt;usize, usize&gt;

pub fn compare_exchange_weak(
    &amp;self,
    current: usize,
    new: usize,
    success: Ordering,
    failure: Ordering
) -&gt; Result&lt;usize, usize&gt;
</code></pre>
<p>compare_exchange比compare_and_swap多了一个Ordering，两个Ordering分别作为CAS成功的Ordering和失败的Ordering，后面会有讲解，这里先跳过。从源代码可以看出compare_and_swap就是用compare_exchange实现的，只是compare_and_swap直接用成功情况下的Ordering生成在失败情况下的Ordering，compare_exchange则有更高的灵活性。</p>
<pre><code class="language-Rust">pub fn compare_and_swap(&amp;self, current: $int_type, new: $int_type, order: Ordering) -&gt; $int_type {
    match self.compare_exchange(current,
                                new,
                                order,
                                strongest_failure_ordering(order)) {
        Ok(x) =&gt; x,
        Err(x) =&gt; x,
    }
}
</code></pre>
<p>既然有了compare_exchange，那compare_exchange_weak是做什么用的呢？从官方文档中可以看出两个API的唯一区别是compare_exchange_weak允许spuriously fail。那么什么是spuriously fail，在x86平台上CAS是一条指令完成的，这两个API在x86平台上效果没有区别，但是在arm平台上，CAS是由两条指令完成的LL/SC(Load-link/store-conditional)，在arm平台下会发生spuriously fail，来自Wikipedia的解释</p>
<blockquote>
<p>Real implementations of LL/SC do not always succeed even if there are no concurrent updates to the memory location in question. Any exceptional events between the two operations, such as a context switch, another  load-link, or even (on many platforms) another load or store operation, will cause the store-conditional to spuriously fail.</p>
</blockquote>
<p>简单的翻译就是，即使变量的值没有被更新LL/SC也不是100%成功，在LL/SC之间的异常事件如上下文切换，另外的LL，甚至load或者store都会导致spuriously fail。由于spuriously fail的存在，arm平台上compare_exchange是compare_exchange_weak加上一个loop实现的。通常我们在使用CAS的时候会把它放在一个loop中，反复重试直到成功，在这种情况下用compare_exchange_weak会获得一定的性能提升，如果用compare_exchange则会导致循环套循环。那我们该如何选择compare_change和compare_exchange_weak呢？如果你想在loop中使用CAS，绝大部分情况下使用compare_exchange_weak，除非你在每一次loop中做的事情很多，spuriously fail会导致很大的overhead即使它很少发生，这种情况下使用compare_exchange。再或者你使用loop就是为了避免spuriously fail，那直接使用compare_exchange就可以达到你的目的。</p>
<p>接下来介绍另外一个重要的原子操作fetch-and-add。</p>
<pre><code class="language-Rust">pub fn fetch_add(&amp;self, val: usize, order: Ordering) -&gt; usize
</code></pre>
<p>fetch_add也包含了读写两层语义，只是和CAS比起来它不关心变量当前的值，所以它一定成功。fetch_add一般用来做全局计数器。
Rust提供了一系列的fetch_and_xxx操作，其中比较有趣的是fetch_update:</p>
<pre><code class="language-Rust">pub fn fetch_update&lt;F&gt;(
    &amp;self,
    set_order: Ordering,
    fetch_order: Ordering,
    f: F
) -&gt; Result&lt;usize, usize&gt;
where
    F: FnMut(usize) -&gt; Option&lt;usize&gt;,
</code></pre>
<p>它会接受一个函数，并将函数应用到变量上，把生成的值写回变量中，因为CPU不支持类似的指令，所以其实fetch_update是使用CAS来实现原子性的。源代码如下，我们可以看这里使用的是compare_exchange_weak，因为它在一个loop中。</p>
<pre><code class="language-Rust">pub fn fetch_update&lt;F&gt;(&amp;self,
                       set_order: Ordering,
                       fetch_order: Ordering,
                       mut f: F) -&gt; Result&lt;$int_type, $int_type&gt;
where F: FnMut($int_type) -&gt; Option&lt;$int_type&gt; {
    let mut prev = self.load(fetch_order);
    while let Some(next) = f(prev) {
        match self.compare_exchange_weak(prev, next, set_order, fetch_order) {
            x @ Ok(_) =&gt; return x,
            Err(next_prev) =&gt; prev = next_prev
        }
    }
    Err(prev)
}
</code></pre>
<h2 id="内存排序"><a class="header" href="#内存排序">内存排序</a></h2>
<p>Rust提供了五种内存排序，由弱到强如下，并且内存排序被标记为<code>#[non_exhaustive]</code>表示未来可能会加入新的类型。</p>
<pre><code class="language-Rust">#[non_exhaustive]
pub enum Ordering {
    Relaxed,
    Release,
    Acquire,
    AcqRel,
    SeqCst,
}
</code></pre>
<p>Rust的内存排序和C++20保持一致。内存排序作用是通过限制编译器和CPU的reorder，来使得多个线程看到的内存顺序和我们程序所期望的一样，所以内存排序主要针对的是内存的读(load)写(store)操作。编译器和CPU会在编译时和运行时来reorder指令来达到提升性能的目的，从而导致程序中代码顺序会和真正执行的顺序可能会不一样，但是reorder的前提是不会影响程序的最终结果，也就是说编译器和CPU不会reorder相互有依赖的指令从而破坏程序原本的语义。比方说两条CPU指令，指令A读取一块内存，指令B写一块内存，如果CPU发现指令A要读取的内容在cache中没有命中需要去内存中读取，需要花额外的CPU cycle，如果指令B要操作的内存已经在cache中命中了，它可以选择先执后面的指令B。这时候内存排序的作用就体现出来了，内存排序告诉编译器和CPU哪些指令可以reorder哪些不可以。接下来分别介绍每一种内存排序的意义。</p>
<ul>
<li>Relaxed：Relaxed Ordering不施加任何限制，CPU和编译器可以自由reorder，使用了Relaxed Ordering的原子操作只保证原子性。</li>
</ul>
<pre><code class="language-Rust">// Global varible
static x: AtomicU32 = AtomicU32::new(0);
static y: AtomicU32 = AtomicU32::new(0);
// Thread 1
let r1 = y.load(Ordering::Relaxed);
x.store(r1, Ordering::Relaxed);
// Thread 2
let r2 = x.load(Ordering::Relaxed); // A
y.store(42, Ordering::Relaxed); // B
</code></pre>
<p>这段程序是允许产生r1 == r2 == 42。按照正常的程序执行，这个结果看似不合理，但是因为使用了Relaxed Ordering，CPU和编译器可以自由reorder指令，指令B被reorder到指令A之前，那就会产生r1 == r2 == 42。</p>
<ul>
<li>
<p>Release：Release Ordering是针对写操作(store)的，一个使用了Release Ordering的写操作，任何读和写操作（不限于对当前原子变量）都不能被reorder到该写操作之后。并且所有当前线程中在该原子操作之前的所有写操作（不限于对当前原子变量）都对另一个对同一个原子变量使用Acquire Ordering读操作的线程可见。Release Ordering写和Acquire Ordering读要配对使用从而在两个或多个线程间建立一种同步关系。具体例子在介绍完Acquire之后一起给出。</p>
</li>
<li>
<p>Acquire：Acquire Ordering是针对读操作(load)的，一个使用了Acquire Ordering的读操作，任何读和写操作（不限于对当前原子变量）都不能被reorder到该读操作之前。并且当前线程可以看到另一个线程对同一个原子变量使用Release Ordering写操作之前的所有写操作（不限于对当前原子变量）。</p>
</li>
</ul>
<p>如果前面的例子中load使用Acquire Ordering，store使用Release Ordering，那么reorder就不会发生，r1 == r2 == 42的结果就不会产生。Acquire和Release动作特别像锁的加锁和释放锁的操作，因此Acquire Ordering和Release Ordering常被用在实现锁的场景。看下面的例子</p>
<pre><code class="language-Rust">// Global varible
static DATA: AtomicU32 = AtomicU32::new(0);
static FLAG: AtomicBool = AtomicBool::new(false);
// Thread 1
DATA.store(10, Ordering::Relaxed); // A
FLAG.store(true, Ordering::Release); // B
// Thread 2
while !FLAG.load(Ordering::Acquire) {} // C
assert!(DATA.load(Ordering::Relaxed) == 10); // D
</code></pre>
<p>这段程序展示了两个线程之间同步的一种方式，在线程1中我们在共享内存中写入数据，然后把FLAG置成true，表明数据写入完成，在线程2中，我们用一个while循环等待FLAG被置成true，当FLAG被置成true之后，线程2一定会读到共享内存中的数据。线程1中的Release Ordering写和线程2中的Acquire Ordering读建立了顺序。当线程2跳出C行的循环表明它可以读到线程1在B行对FLAG的写入，按照Release-Acquire Ordering的保证，A行对DATA的写入不会被reorder到把FLAG置成true之后，并且对DATA的写入也会对线程2可见。假如这里没有使用Release-Acquire Ordering，那么线程对DATA的写入用可能会被reorder到写FLAG之后，那么线程2就会出现读到了FLAG但是读不到DATA的情况。</p>
<ul>
<li>AcqRel：AcqRel Ordering主要用于read-modify-write类型的操作，比如compare_and_swap，表明了它同时具有Acquire和Release的语义，读的部分用Acquire Ordering，写的部分用Release Ordering。</li>
<li>SeqCst：SeqCst是Sequential Consistent的缩写，是一种最强的Ordering，在对读使用Acquire Ordering，对写使用Release Ordering，对read-modify-write使用AcqRel Ordering的基础上再保证所有线程看到所有使用了SeqCst Ordering的操作是同一个顺序，不论操作的是不是同一个变量。</li>
</ul>
<p>这里包含了两层意思，第一层意思SeqCst禁止了所有的reorder，针对内存读(load)写(store)的reorder一共有四种情况：</p>
<ul>
<li>loadload reorder：Arquire Ordering保证</li>
<li>loadstore reorder：Arquire Ordering和Release Ordering保证</li>
<li>storestore reorder：Release Ordering保证</li>
<li>storeload reorder：SeqCst Ordering保证</li>
</ul>
<p>看下面的例子</p>
<pre><code class="language-Rust">// Global varible
static x: AtomicU32 = AtomicU32::new(0);
static y: AtomicU32 = AtomicU32::new(0);
// Thread 1
x.store(1, Ordering::SeqCst);  // A
let r1 = y.load(Ordering::SeqCst); // B
// Thread 2
y.store(1, Ordering::SeqCst); // C
let r2 = x.load(Ordering::SeqCst);  // D
</code></pre>
<p>这里如果不使用SeqCst Ordering就会出现r1 == r2 == 0的结果，原因是每一个线程中的load可以被reorder到store之前，即使我们分别对load和store使用Acquire Ordering和Release Ordering，因为它们都不保证storeload的reorder。</p>
<p>SeqCst Ordering的第二层意思是所有使用了SeqCst Ordering的操作在全局有一个顺序，并且所有的线程都看到同样的顺序。比如说全局的顺序是A-&gt;B-&gt;C-&gt;D，那么r1 == 0 &amp;&amp; r2 == 1，并且第三个线程如果看到了y == 1，那么它一定能看到x == 1，这就是SeqCst Ordering全局唯一顺序代表的意义。虽然使用SeqCst Ordering可以保证更严格的全局一致性，但是它也会带来性能损失，使用正确并且合适的内存排序才能获得最优的性能。</p>
<p>最后解释一下compare_exchange两个Ordering的含义，CAS包含1.读变量，2.和期望值比较，3.写变量三个步骤，第一个Ordering表示CAS成功下即变量当前的值等于期望值时候，整个操作的Ordering，第二个Ordering表示如果当前比较失败了情况下，第一步读操作的Ordering。看一个用CAS实现自旋锁的例子</p>
<pre><code class="language-Rust">// Global lock
static LOCK: AtomicBool = AtomicBool::new(false);
// Thread 1
// Get lock
while(LOCK.compare_exchange_weak(false, true, Ordering::Acquire, Ordering::Relaxed).is_err()) {}
do_something();
// Unlock
LOCK.store(false, Ordering::Release);

// Thread 2
// Get lock
while(LOCK.compare_exchange_weak(false, true, Ordering::Acquire, Ordering::Relaxed).is_err()) {}
do_something();
// Unlock
LOCK.store(false, Ordering::Release);
</code></pre>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>本文介绍了Rust提供的原子类型，原子操作以及和原子操作配合使用的内存排序。深入地理解内存排序才能写出正确并且性能最优的程序。内存排序是一个很深的话题，如有错误，欢迎指正，欢迎在评论区留言交流。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-for-linux-源码导读--rust-驱动开发与通用时钟管理框架抽象"><a class="header" href="#rust-for-linux-源码导读--rust-驱动开发与通用时钟管理框架抽象">Rust for Linux 源码导读 | Rust 驱动开发与通用时钟管理框架抽象</a></h1>
<p>作者： 张汉东</p>
<blockquote>
<p>推荐阅读： <a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_12/ref.html">Rust for Linux 源码导读 | Ref 引用计数容器</a></p>
</blockquote>
<h2 id="背景概念"><a class="header" href="#背景概念">背景概念</a></h2>
<p>Rust for Linux 这个项目的目的就是为了将 Rust 引入 Linux，让 Rust 成为 C 语言之后的第二语言。但它最初的目的是：实验性地支持Rust来写内核驱动。</p>
<p>以往，Linux 内核驱动的编写相对于应用其实是比较复杂的，具体复杂性主要表现在以下两个方面：</p>
<ul>
<li>编写设备驱动必须了解Linux 内核基础概念、工作机制、硬件原理等知识</li>
<li>设备驱动中涉及内存和多线程并发时容易出现 Bug，linux驱动跟linux内核工作在同一层次，一旦发生问题，很容易造成内核的整体崩溃</li>
</ul>
<p>引入 Rust 从理想层面来看，一方面在代码抽象和跨平台方面比 C 更有效，另一方面代码质量会更高，有效减少内存和多线程并发类 Bug 。但具体实践如何，是否真如理想中有效，这就需要后续的实验。</p>
<p>Rust for Linux 就是为了帮助实现这一目标，为 Linux 提供了 Rust 相关的基础设施和方便编写 Linux 驱动的安全抽象。</p>
<h2 id="rust-for-linux-第四次补丁提审-1"><a class="header" href="#rust-for-linux-第四次补丁提审-1">Rust for Linux 第四次补丁提审</a></h2>
<p>补丁的具体细节可以在Linux 邮件列表中找到：</p>
<ul>
<li>RFC: https://lore.kernel.org/lkml/20210414184604.23473-1-ojeda@kernel.org/</li>
<li>v1:  https://lore.kernel.org/lkml/20210704202756.29107-1-ojeda@kernel.org/</li>
<li>v2:  https://lore.kernel.org/lkml/20211206140313.5653-1-ojeda@kernel.org/</li>
<li>v3:  https://lore.kernel.org/lkml/20220117053349.6804-1-ojeda@kernel.org/</li>
</ul>
<p>第二次补丁改进摘要可参考：<a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_12/ref.html">Rust for Linux 源码导读 | Ref 引用计数容器</a>。</p>
<p><strong>第三次补丁改进摘要：</strong></p>
<ul>
<li>对 Rust 的支持有一些改进：
<ul>
<li>升级到 Rust 1.58.0</li>
<li>增加了自动检测来判断是否有合适的 Rust 可用工具链（<code>CONFIG_RUST_IS_AVAILABLE</code>，用于替换<code>HAS_RUST</code>）</li>
<li>移除<code>!COMPILE_TEST</code> </li>
<li>其他构建系统的改进</li>
<li>文档改进</li>
<li>需要的不稳定功能之一，<code>-Zsymbol-mangling-version=v0</code>，在 1.59.0 中变得稳定。另一个，“maybe_uninit_extra”，将在 1.60.0 中。</li>
</ul>
</li>
<li>对抽象和示例驱动程序的一些改进：
<ul>
<li>加了将在总线中使用的“IdArray”和“IdTable”，以允许驱动程序指定在编译时保证为零终止（zero-terminated）的设备 ID 表。</li>
<li>更新了 <code>amba</code> 以使用新的常量设备 ID 表支持。</li>
<li>初始通用时钟框架抽象。</li>
<li>平台驱动程序现在通过实现特质（trait）来定义。包括用于简化平台驱动程序注册的新宏和新示例/模板。</li>
<li><code>dev_*</code> 打印宏。</li>
<li><code>IoMem&lt;T&gt;</code> 的<code>{read,write}*_relaxed</code> 方法。</li>
<li>通过删除 <code>FileOpener</code> 来简化文件操作。</li>
<li>在驱动程序注册的参数中添加了“ThisModule”。</li>
<li>添加用 Rust 编写的树外 Linux 内核模块的基本模板： [https ://github.com/Rust-for-Linux/rust-out-of-tree-module](https ://github.com/Rust-for-Linux/rust-out-of-tree-module)</li>
</ul>
</li>
</ul>
<p><strong>第四次补丁改进摘要：</strong></p>
<ul>
<li>基础设施更新：
<ul>
<li>整合 CI : 英特尔 0DAY/LKP 内核测试机器人 / kernelCI/ GitHub CI</li>
<li>内核模块不需要写 crate 属性，<code>#![no_std]</code> 和 <code>#![feature(...)]</code> 不再存在，删除样板。</li>
<li>添加了单目标支持，包括<code>.o</code>、<code>.s</code>、<code>.ll</code>和<code>.i</code>（即宏扩展，类似于 C 预处理源）。</li>
<li>对<code>helpers.c</code>文件的解释和对helpers的许可和导出的许可。</li>
<li>文档Logo现在基于矢量 (SVG)。此外，已经为上游提出了 Tux 的矢量版本，并且用于改进自定义Logo支持的 RFC 已提交至上游 Rust。</li>
<li>添加了关于注释 (<code>//</code>) 和代码文档的编码指南(<code>///</code>)。</li>
<li><code>is_rust_module.sh</code> 返工。</li>
<li>现在跳过了叶子模块的<code>.rmeta</code>的生成。</li>
<li>其他清理、修复和改进。</li>
</ul>
</li>
<li>抽象和驱动更新:
<ul>
<li>
<p>增加了对静态（全局共享变量）同步原语的支持。<code>CONFIG_CONSTRUCTORS</code>被用于实现。</p>
</li>
<li>
<p>通过使用标记类型简化了锁防护，即<code>Guard</code>和<code>GuardMut</code>统一为一个参数化的类型。如果标记是 <code>WriteLock</code>，那么 <code>Guard</code>就会实现<code>DerefMut</code>（以前只由<code>GuardMut</code>实现）。</p>
</li>
<li>
<p>可选参数添加到杂项设备（misc device）的注册中。遵循构建者模式，例如:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>miscdev::Options::new()
    .mode(0o600)
    .minor(10)
    .parent(parent)
    .register(reg, c_str!(&quot;sample&quot;), ())
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>增加了 &quot;RwSemaphore &quot;的抽象，该抽象包裹了C端<code>struct rw_semaphore</code>。</p>
</li>
<li>
<p>新的<code>mm</code>模块和VMA抽象（包装C端<code>struct vm_area_struct</code>）用于<code>mmap</code>。</p>
</li>
<li>
<p>GPIO PL061现在使用最近增加的<code>dev_*!</code> Rust宏。</p>
</li>
<li>
<p>支持<code>！CONFIG_PRINTK</code>情况。</p>
</li>
<li>
<p>其他清理、修复和改进。</p>
</li>
</ul>
</li>
</ul>
<h2 id="rust-与-linux-设备驱动开发"><a class="header" href="#rust-与-linux-设备驱动开发">Rust 与 Linux 设备驱动开发</a></h2>
<h3 id="基础概念"><a class="header" href="#基础概念">基础概念</a></h3>
<p>和应用程序不同，驱动程序是可以直接和硬件设备进行通讯的。驱动程序作为 Linux 内核的一种模块被动态加载到内核中。编译好的模块一般以<code>.ko</code>（kernel object）为文件扩展后缀 (这让我想起自己在 Linux 下安装 Nvidia 驱动报错找不到 <code>nvidia.ko</code> 文件时有多么崩溃)。</p>
<blockquote>
<p>但要注意的是，驱动不一定必须是模块，有些驱动是直接编译进内核的；同时模块也不全是驱动。</p>
</blockquote>
<p><strong>创建内核驱动基本模式如下：</strong></p>
<ol>
<li>通过实现初始化入口点和退出点来对应内核加载和卸载驱动的行为</li>
</ol>
<p>基于 Rust for Linux 提供的 <code>kernel</code> 库来实现驱动的话，代码如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: https://github.com/Rust-for-Linux/linux/blob/rust/samples/rust/rust_miscdev.rs

// RustMiscdev 是某个设备
// 通过实现 KernelModule trait 来进行加载时初始化
impl KernelModule for RustMiscdev {
    fn init(name: &amp;'static CStr, _module: &amp;'static ThisModule) -&gt; Result&lt;Self&gt; {
        pr_info!(&quot;Rust miscellaneous device sample (init)\n&quot;);

        let state = SharedState::try_new()?;

        Ok(RustMiscdev {
            _dev: miscdev::Registration::new_pinned(fmt!(&quot;{name}&quot;), state)?,
        })
    }
}

// 通过实现 Drop trait 来进行卸载时的清理
impl Drop for RustMiscdev {
    fn drop(&amp;mut self) {
        pr_info!(&quot;Rust miscellaneous device sample (exit)\n&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<ol start="2">
<li>编写驱动逻辑</li>
</ol>
<p>比如实现文件操作之类：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: https://github.com/Rust-for-Linux/linux/blob/rust/samples/rust/rust_miscdev.rs

struct Token;

// 通过实现 kernel crate 中抽象的 FileOperations 接口
impl FileOperations for Token {
    type Wrapper = Ref&lt;SharedState&gt;;
    type OpenData = Ref&lt;SharedState&gt;;

    kernel::declare_file_operations!(read, write);

    fn open(shared: &amp;Ref&lt;SharedState&gt;, _file: &amp;File) -&gt; Result&lt;Self::Wrapper&gt; {
        Ok(shared.clone())
    }

    fn read(
        shared: RefBorrow&lt;'_, SharedState&gt;,
        _: &amp;File,
        data: &amp;mut impl IoBufferWriter,
        offset: u64,
    ) -&gt; Result&lt;usize&gt; {
        // do_something
    }

    // do more things
}
<span class="boring">}
</span></code></pre></pre>
<ol start="3">
<li>编译、加载和测试等。</li>
</ol>
<p>编写 Linux 驱动有很多细节内容，这里只是介绍一个简单的模式，来帮助理解 Rust for Linux 中的 <code>kernel</code> 抽象的作用。</p>
<h3 id="rust-驱动开发示例"><a class="header" href="#rust-驱动开发示例">Rust 驱动开发示例</a></h3>
<p>去年有人提交过一份 C vs Rust 驱动代码示例：<a href="https://lwn.net/Articles/863459/">A GPIO driver in Rust</a>。可以看得出来，Rust 对硬件抽象的表达能力显著要高于 C 语言。</p>
<p>下面是这段驱动代码实现的摘要：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use core::ops::DerefMut;
use kernel::{
    amba, bit, declare_id_table, device, gpio,
    io_mem::IoMem,
    irq::{self, IrqData, LockedIrqData},
    power,
    prelude::*,
    sync::{IrqDisableSpinLock, Ref},
};

impl gpio::Chip for PL061Device { 
    // do_something
}

impl irq::Chip for PL061Device {
    // do_something
}

impl amba::Driver for PL061Device {
    // do_something
}

impl power::Operations for PL061Device {
    // do_something
}

module_amba_driver! {
    type: PL061Device,
    name: b&quot;pl061_gpio&quot;,
    author: b&quot;Wedson Almeida Filho&quot;,
    license: b&quot;GPL v2&quot;,
}

<span class="boring">}
</span></code></pre></pre>
<p>这段驱动代码中使用了 Rust for Linux 中提供的 <code>kernel</code> 库，用其中包括的抽象 <code>gpio</code>、<code>irq</code>、<code>amba</code>、<code>power</code>准确表达了这段驱动代码中的结构和实现意图，可以更好地和驱动开发者对驱动开发建立的心智模型对应起来，这就是 Rust 语言的抽象表达能力。</p>
<ul>
<li><code>gpio::Chip</code> trait 是对 gpio chip 的一种跨平台抽象接口，它也是一种依赖倒置。让底层不同的gpio chip都依赖同一个接口。</li>
<li><code>irq::Chip</code> trait 是对内核中 <code>irq_data</code>结构体的抽象接口。中断描述符中会包括底层irq chip相关的数据结构，内核中把这些数据组织在一起，形成<code>struct irq_data</code>。</li>
<li><code>amba::Driver</code> trait 是 amba（高级微控制器总线结构，）设备驱动抽象接口，由于ARM众多的合作伙伴都会或多或少的使用ARM提供的片内外设，所以众多厂商的ARM处理器的一些外设可以使用相同的驱动。这个 GPIO 驱动也是针对 ARM 平台写的，所以用到这个。</li>
<li><code>power::Operations</code> trait 是对 Linux 电源管理中各种 Callback 数据结构<code>dev_pm_ops</code>的抽象接口。<code>power</code> 模块中还定义了方便设置callback的宏等。</li>
</ul>
<p>看得出来，基于 Rust for Linux 的 <code>kernel</code> 抽象，可以方便地使用 Rust 开发架构良好、可读性强、易维护且更加健壮的内核驱动代码。</p>
<h2 id="linux-通用时钟框架介绍"><a class="header" href="#linux-通用时钟框架介绍">Linux 通用时钟框架介绍</a></h2>
<h3 id="背景介绍"><a class="header" href="#背景介绍">背景介绍</a></h3>
<p>当下通用计算机中的CPU中各个模块都需要时钟驱动，内核就需要一套通用的机制来进行时钟管理。这套通用机制还必须跨平台地方便管理CPU上所有的时钟资源。</p>
<p>Linux 平台中提供一套通用时钟框架（common clock framework）来管理系统clock资源的子系统，其职能可以分为下面三个部分：</p>
<ul>
<li>向其它driver提供操作clocks的通用API。</li>
<li>实现clock控制的通用逻辑，这部分和硬件无关。</li>
<li>将和硬件相关的clock控制逻辑封装成操作函数集，交由底层的platform开发者实现，由通用逻辑调用。</li>
</ul>
<p>现在主流的 Linux 处理器平台都包含了非常复杂的 clock tree，对应很多clock相关的器件。而这个通用时钟框架管理的对象就是这些clock器件。框架的主要功能包括：</p>
<ul>
<li>使能（enable/disable）clk</li>
<li>设置clk频率</li>
<li>选择clk的parent</li>
</ul>
<p>通用时钟框架的通用接口定义在 Linux 内核中（<a href="https://github.com/Rust-for-Linux/linux/blob/rust/include/linux/clk.h">include/linux/clk.h</a>）。</p>
<p>每个时钟源对象使用一个<code>struct clk</code>结构来表示。而<code>struct clk</code>结构的具体内容由各平台自己定义。<code>clk.h</code>头文件定义了操作一个clk对象的所有接口。内核的其他地方可以也只能使用<code>clk.h</code>中提供的这些接口函数来操作<code>clk</code>。Rust for Linux 的 <code>kernel</code> crate 就是对 <code>clk.h</code> 的封装。这也是 Rust for Linux 第四次提审的补丁改进的内容之一。</p>
<p>关于通用时钟框架还有很多细节，这里为了帮助理解代码，只做简要介绍，对细节感兴趣的朋友可以自行检索学习资料（例如：<a href="http://www.wowotech.net/pm_subsystem/clk_overview.html">http://www.wowotech.net/pm_subsystem/clk_overview.html</a>）。</p>
<h3 id="rust-for-linux-中的简单抽象"><a class="header" href="#rust-for-linux-中的简单抽象">Rust for Linux 中的简单抽象</a></h3>
<p>Rust 对 <code>clk.h</code> 对绑定相对比较简单，只绑定了部分控制clock的接口，比如 <code>prepare_enable/disable_unprepare</code> 和 <code>get_rate</code>，还有很多接口没有绑定。另外只能用于 atomic 上下文。</p>
<p>但我们能从中学习到 Unsafe Rust的一些最佳实践（注意代码中的注释）：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: https://github.com/Rust-for-Linux/linux/blob/rust/rust/kernel/clk.rs

use crate::{bindings, error::Result, to_result};
use core::mem::ManuallyDrop;

/// 表示 `struct clk *`
///
/// # Invariants （不变性说明）
///
/// 这个指针来自 C语言 端，这里默认 C 端来的是有效指针，信任 C 端
/// 这种信任对性能有益：零成本（没有检查开销）
pub struct Clk(*mut bindings::clk);

impl Clk {
    /// Creates new clock structure from a raw pointer.
    ///
    /// # Safety
    ///
    /// The pointer must be valid.
    /// 这里使用unsafe 函数，是因为无法保证传入的指针是否有效，只能靠其调用者来保证
    /// 所以无法将其抽象为安全防范
    pub unsafe fn new(clk: *mut bindings::clk) -&gt; Self {
        Self(clk)
    }

    /// Returns value of the rate field of `struct clk`.
    pub fn get_rate(&amp;self) -&gt; usize {
        // SAFETY: The pointer is valid by the type invariant.
        // 安全性说明：这个指针已经有上嘛结构体定义时的不变性来保证安全了，所以这是个安全方法
        unsafe { bindings::clk_get_rate(self.0) as usize }
    }

    /// Prepares and enables the underlying hardware clock.
    ///
    /// This function should not be called in atomic context.
    pub fn prepare_enable(self) -&gt; Result&lt;EnabledClk&gt; {
        // SAFETY: The pointer is valid by the type invariant.
        // 同上
        to_result(|| unsafe { bindings::clk_prepare_enable(self.0) })?;
        Ok(EnabledClk(self))
    }

    impl Drop for Clk {
    fn drop(&amp;mut self) {
        // SAFETY: The pointer is valid by the type invariant.
        unsafe { bindings::clk_put(self.0) };
    }
}


// 对clock 使能
/// A clock variant that is prepared and enabled.
pub struct EnabledClk(Clk);

impl EnabledClk {
    // 获取频率
    /// Returns value of the rate field of `struct clk`.
    pub fn get_rate(&amp;self) -&gt; usize {
        self.0.get_rate()
    }

    /// Disables and later unprepares the underlying hardware clock prematurely.
    ///
    /// This function should not be called in atomic context.
    pub fn disable_unprepare(self) -&gt; Clk {
        let mut clk = ManuallyDrop::new(self);
        // SAFETY: The pointer is valid by the type invariant.
        unsafe { bindings::clk_disable_unprepare(clk.0 .0) };
        core::mem::replace(&amp;mut clk.0, Clk(core::ptr::null_mut()))
    }
}

impl Drop for EnabledClk {
    fn drop(&amp;mut self) {
        // SAFETY: The pointer is valid by the type invariant.
        // 安全性同上
        unsafe { bindings::clk_disable_unprepare(self.0 .0) };
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>上面 <code>clk</code> Rust 安全绑定代码虽然简单，但它反映出了 Rust for Linux 中 Unsafe Rust 安全抽象的一种规范：<strong>利用文档注释中不变性声明，强调了对依赖的内核 C 代码的信任，从而减少了检查达到零成本抽象。</strong> 关于这一点在 <a href="https://github.com/Rust-for-Linux/linux/pull/324">https://github.com/Rust-for-Linux/linux/pull/324</a> 中有很多讨论。</p>
<p>除clk之外还有 Device 也有部分相关代码。设备驱动在操作设备的clock之前，需要先获取和该clock关联的<code>struct clk</code>指针，在 Rust 代码中就是 <code>clk_ptr</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// From: https://github.com/Rust-for-Linux/linux/blob/rust/rust/kernel/device.rs

#[cfg(CONFIG_COMMON_CLK)]
use crate::{clk::Clk, error::from_kernel_err_ptr};

// 该 trait 是一个 Unsafe trait
// 注释表明，在实现该 trait 的时候需要注意满足其安全条件
/// A raw device.
///
/// # Safety
///
/// Implementers must ensure that the `*mut device` returned by [`RawDevice::raw_device`] is
/// related to `self`, that is, actions on it will affect `self`. For example, if one calls
/// `get_device`, then the refcount on the device represented by `self` will be incremented.
///
/// Additionally, implementers must ensure that the device is never renamed. Commit a5462516aa994
/// has details on why `device_rename` should not be used.
pub unsafe trait RawDevice {
    
    // do more things

    // clk_get 方法是一个默认实现
    /// Lookups a clock producer consumed by this device.
    ///
    /// Returns a managed reference to the clock producer.
    #[cfg(CONFIG_COMMON_CLK)]
    fn clk_get(&amp;self, id: Option&lt;&amp;CStr&gt;) -&gt; Result&lt;Clk&gt; {
        let id_ptr = match id {
            Some(cstr) =&gt; cstr.as_char_ptr(),
            None =&gt; core::ptr::null(),
        };

        // 安全性保证： `id_ptr`是一个可选值，要么是有效指针 要么是空指针，应该不会产生UB
        // 但是有效性也是依赖对 Linux C 语言端绑定指针的信任
        // SAFETY: `id_ptr` is optional and may be either a valid pointer
        // from the type invariant or NULL otherwise.
        let clk_ptr = unsafe { from_kernel_err_ptr(bindings::clk_get(self.raw_device(), id_ptr)) }?;

        // 因为上面的 `bindings::clk_get` 安全，那其返回值也认为是有效指针
        // SAFETY: Clock is initialized with valid pointer returned from `bindings::clk_get` call.
        unsafe { Ok(Clk::new(clk_ptr)) }
    }

    // do more things 
}

<span class="boring">}
</span></code></pre></pre>
<p>看得出来， <code>SAFETY</code> 注释粒度非常细，因为它依赖一个前提</p>
<p>另外，关于更多 Unsafe Rust 代码规范可以参考：<a href="https://rust-coding-guidelines.github.io/rust-coding-guidelines-zh/safe-guides/coding_practice/unsafe_rust.html">Rust 编码规范 - Unsafe Rust 部分</a></p>

                    </main>

                    <script src="https://utteranc.es/client.js"
                    repo="RustMagazine/rust_magazine_2022"
                    issue-term="title"
                    theme="github-light"
                    crossorigin="anonymous"
                    async></script>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="mermaid.min.js"></script>
        <script type="text/javascript" src="mermaid-init.js"></script>
        <script type="text/javascript" src="smart-anchor.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
